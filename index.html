<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake AI p5.js + A*</title>
<script src="https://cdn.jsdelivr.net/npm/p5@1.3.1/lib/p5.js"></script>
<style>
  body { margin:0; background:#000; display:flex; justify-content:center; align-items:center; height:100vh; }
  canvas { display:block; }
</style>
</head>
<body>
<script>
// ====== Настройки ======
const COLS = 40;
const ROWS = 20;
const CELL = 30;
const TOTAL_CELLS = COLS*ROWS;

// ====== Класс Apple ======
class Apple {
    constructor() {
        this.generate([{x:-1,y:-1}]);
    }
    generate(snake_body){
        let empty = [];
        for(let x=0;x<COLS;x++){
            for(let y=0;y<ROWS;y++){
                if(!snake_body.some(s=>s.x===x && s.y===y)){
                    empty.push({x,y});
                }
            }
        }
        if(empty.length===0) return false;
        this.pos = empty[int(random(empty.length))];
        return true;
    }
    show() {
        fill('#ee0a17');
        noStroke();
        rect(this.pos.x*CELL, this.pos.y*CELL, CELL, CELL);
    }
}

// ====== Класс Snake ======
class Snake {
    constructor() {
        this.body = [{x:5,y:5}];
        this.path = [];
        this.survival = false;
        this.gameOver = false;
    }
    getHead(){ return this.body[0]; }
    getTail(){ return this.body[this.body.length-1]; }

    move(){
        if(this.path.length>0){
            const next = this.path.shift();
            if(this.body.some(s=>s.x===next.x && s.y===next.y)){
                this.gameOver = true; return;
            }
            this.body.unshift(next);
            if(next.x===apple.pos.x && next.y===apple.pos.y){
                apple.generate(this.body);
                this.path=[];
            } else {
                this.body.pop();
            }
        }
    }

    show(){
        fill(this.gameOver ? '#808080' : (this.survival ? '#b20c18' : '#3ac322'));
        noStroke();
        for(let s of this.body){
            rect(s.x*CELL, s.y*CELL, CELL, CELL);
        }
    }
}

// ====== Класс Search ======
class Search {
    constructor(snake, apple){
        this.snake = snake;
        this.apple = apple;
    }

    neighbors(node, snake_body){
        const deltas=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
        return deltas.map(d=>({x:node.x+d.x, y:node.y+d.y}))
                     .filter(n=>n.x>=0 && n.x<COLS && n.y>=0 && n.y<ROWS)
                     .filter(n=>!snake_body.some(s=>s.x===n.x && s.y===n.y));
    }

    heuristic(a,b){ return abs(a.x-b.x)+abs(a.y-b.y); }

    reachableCells(startPos, occupied){
        const queue=[startPos];
        const visited=new Set([`${startPos.x},${startPos.y}`]);
        let count=1;
        while(queue.length>0){
            const cur = queue.shift();
            const deltas=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
            for(let d of deltas){
                const nx=cur.x+d.x, ny=cur.y+d.y;
                if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
                if(occupied.some(s=>s.x===nx&&s.y===ny)) continue;
                const key=`${nx},${ny}`;
                if(!visited.has(key)){
                    visited.add(key);
                    queue.push({x:nx,y:ny});
                    count++;
                }
            }
        }
        return count;
    }

    // ====== обычный A* ======
    astar(){
        const start = this.snake.getHead();
        const goal = apple.pos;
        let open = [{node:start, g:0, f:this.heuristic(start,goal), parent:null}];
        let closed = [];
        while(open.length>0){
            open.sort((a,b)=>a.f-b.f);
            const current = open.shift();
            if(current.node.x===goal.x && current.node.y===goal.y){
                let p=[]; let c=current;
                while(c){ p.unshift(c.node); c=c.parent; }
                return p.slice(1);
            }
            closed.push(current.node);
            for(const n of this.neighbors(current.node, this.snake.body)){
                if(closed.some(c=>c.x===n.x && c.y===n.y)) continue;
                const future=[n,...this.snake.body];
                const empty=TOTAL_CELLS-future.length;
                if(this.reachableCells(future[0],future)<Math.floor(0.8*empty)) continue;
                let g=current.g+1;
                let f=g+this.heuristic(n,goal);
                if(open.some(o=>o.node.x===n.x && o.node.y===n.y && o.f<=f)) continue;
                open.push({node:n,g,f,parent:current});
            }
        }
        return null;
    }

    // The main A* pathfinding algorithm
    // References: https://en.wikipedia.org/wiki/A*_search_algorithm
    // and https://medium.com/@nicholas.w.swift/easy-a-star-pathfinding-7e6689c7f7b2
    // g value is given by the distance from the start_node to current node
    // h value is given by the Manhattan distance between current node and end_node
    reversedAStar(maze, start, end) {
        let start_node = new Node(start.x, start.y);
        let end_node = new Node(end.x, end.y);
        let open_list = [];
        let closed_list = [];
        open_list.push(start_node);
        let possible_paths = [];
        const adjacent_squares = [
            [0, -1],
            [0, 1],
            [-1, 0],
            [1, 0],
        ];

        while (open_list.length > 0) {

            let current_node = open_list[0];
            let current_index = 0;
            let index = 0;

            for (let i = 0; i < open_list.length; i++) {
                if (open_list[i].f > current_node.f) {
                    current_node = open_list[i];
                    current_index = index;
                }
                index++;
            }

            open_list.splice(current_index, 1);
            closed_list.push(current_node);
            if (current_node.equals(end_node)) {
                let path = [];
                let current = current_node;
                while (current != null) {
                    path.push(current);
                    current = current.parent;
                }
                possible_paths.push(path.reverse());
            }

            let children = [];
            for (let i = 0; i < adjacent_squares.length; i++) {
                let node_position = [current_node.x + adjacent_squares[i][0], current_node.y + adjacent_squares[i][1]];
                if (node_position[0] <= 39 && node_position[0] >= 0) {
                    if (node_position[1] <= 19 && node_position[1] >= 0) {
                        if (maze[node_position[1]][node_position[0]] != -1) {
                            let new_node = new Node(node_position[0], node_position[1]);
                            children.push(new_node);
                        }
                    }
                }
            }

            for (let i = 0; i < children.length; i++) {
                let if_in_closed_list = false;
                for (let j = 0; j < closed_list.length; j++) {
                    if (children[i].equals(closed_list[j])) {
                        if_in_closed_list = true;
                    }
                }
                if (!if_in_closed_list) {
                    children[i].g = current_node.g + 2;
                    children[i].h = abs(children[i].x - end_node.x) + abs(children[i].y - end_node.y);
                    children[i].f = children[i].g + children[i].h;
                    let present = false;
                    for (let j = 0; j < open_list.length; j++) {
                        if (children[i].equals(open_list[j]) && children[i].g < open_list[j].g) {
                            present = true;
                        } else if (children[i].equals(open_list[j]) && children[i].g >= open_list[j].g) {
                            open_list[j] = children[i];
                            open_list[j].parent = current_node;
                        }
                    }
                    if (!present) {
                        children[i].parent = current_node;
                        open_list.push(children[i]);
                    }
                }
            }
        }
        let path = [];
        for (let i = 0; i < possible_paths.length; i++) {
            if (possible_paths[i].length > path.length) {
                path = possible_paths[i];
            }
        }
        return path;
    }
}
    getPath(){
        const threshold=Math.floor(TOTAL_CELLS/8);
        if(this.snake.body.length<=threshold){
            this.snake.path=this.astar();
            this.snake.survival=false;
        } else {
            this.snake.path=this.reversedAStar();
            this.snake.survival=false;
        }
        if(!this.snake.path || this.snake.path.length===0){
            // survival mode
            const nbs=this.neighbors(this.snake.getHead(),this.snake.body);
            if(nbs.length>0) this.snake.path=[nbs[0]];
            else this.snake.path=[this.snake.getHead()];
            this.snake.survival=true;
        }
    }
}

// ====== Инициализация ======
let snake, apple, search;
function setup(){
    createCanvas(COLS*CELL,ROWS*CELL);
    snake=new Snake();
    apple=new Apple();
    search=new Search(snake,apple);
    search.getPath();
    frameRate(10);
}

// ====== Игровой цикл ======
function draw(){
    background('#151515');
    snake.show();
    apple.show();
    if(!snake.gameOver){
        if(snake.path.length===0) search.getPath();
        snake.move();
    }
}
</script>
</body>
</html>
