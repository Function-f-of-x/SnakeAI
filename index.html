<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake AI</title>
<style>
  body {
    margin: 0;
    background-color: #000000;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }
  canvas {
    background-color: #151515;
    display: block;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const GRID_SIZE = 54; // размер квадрата сетки
const SNAKE_SIZE = 48; // размер квадрата змейки
const APPLE_SIZE = 51; // размер яблока
const GRID_WIDTH = 12; // количество клеток по ширине
const GRID_HEIGHT = 12; // количество клеток по высоте

const snakeColorNormal = "#3ac322";
const snakeColorSurvival = "#b20c18";
const appleColor = "#ee0a17";

const canvas = document.getElementById("game");
canvas.width = GRID_WIDTH * GRID_SIZE;
canvas.height = GRID_HEIGHT * GRID_SIZE;
const ctx = canvas.getContext("2d");

let snake = [{x: 5, y: 5}];
let direction = {x: 1, y: 0};
let apple = {x: Math.floor(Math.random()*GRID_WIDTH), y: Math.floor(Math.random()*GRID_HEIGHT)};
let survivalMode = false;

// Проверка безопасного пути (≥80% пустых клеток после движения)
function safePath(grid, path) {
    let tempSnake = [...snake];
    for (let step of path) {
        tempSnake.push(step);
        tempSnake.shift(); // двигаем змейку
    }
    // строим сетку после движения
    let free = 0, total = 0;
    for (let y=0; y<GRID_HEIGHT; y++) {
        for (let x=0; x<GRID_WIDTH; x++) {
            total++;
            if (!tempSnake.some(s => s.x===x && s.y===y)) free++;
        }
    }
    return (free/total) >= 0.8;
}

// A* поиск кратчайшего пути к яблоку
function aStar(start, end, gridSnake) {
    const open = [];
    const cameFrom = {};
    const gScore = {};
    const fScore = {};
    
    function key(p){ return p.x+","+p.y; }
    
    gScore[key(start)] = 0;
    fScore[key(start)] = Math.abs(start.x-end.x)+Math.abs(start.y-end.y);
    open.push({...start, f: fScore[key(start)]});
    
    const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
    
    while(open.length){
        open.sort((a,b)=>a.f-b.f);
        let current = open.shift();
        if(current.x===end.x && current.y===end.y){
            let path = [];
            let k = key(current);
            while(cameFrom[k]){
                path.push(cameFrom[k]);
                k = key(cameFrom[k]);
            }
            path.reverse();
            return path;
        }
        for(let d of dirs){
            let nx = current.x+d.x;
            let ny = current.y+d.y;
            if(nx<0 || ny<0 || nx>=GRID_WIDTH || ny>=GRID_HEIGHT) continue;
            if(gridSnake.some(s=>s.x===nx && s.y===ny)) continue;
            let neighbor = {x:nx,y:ny};
            let tentativeG = gScore[key(current)] + 1;
            if(tentativeG < (gScore[key(neighbor)] || Infinity)){
                cameFrom[key(neighbor)] = current;
                gScore[key(neighbor)] = tentativeG;
                fScore[key(neighbor)] = tentativeG + Math.abs(nx-end.x)+Math.abs(ny-end.y);
                if(!open.some(o=>o.x===nx && o.y===ny)) open.push({...neighbor, f:fScore[key(neighbor)]});
            }
        }
    }
    return null; // пути нет
}

// Reversed A*: поиск максимально длинного безопасного пути
function reversedAStar(start, end, gridSnake) {
    // Простая стратегия: BFS со случайным приоритетом пустых клеток, выбираем путь с максимальной длиной
    const visited = {};
    let queue = [[start]];
    let bestPath = null;
    
    const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
    
    while(queue.length){
        let path = queue.shift();
        let current = path[path.length-1];
        if(current.x===end.x && current.y===end.y){
            if(!bestPath || path.length > bestPath.length){
                bestPath = path;
            }
            continue;
        }
        for(let d of dirs.sort(()=>Math.random()-0.5)){
            let nx = current.x+d.x;
            let ny = current.y+d.y;
            if(nx<0 || ny<0 || nx>=GRID_WIDTH || ny>=GRID_HEIGHT) continue;
            if(gridSnake.some(s=>s.x===nx && s.y===ny)) continue;
            let key = nx+","+ny;
            if(visited[key]) continue;
            visited[key] = true;
            queue.push([...path,{x:nx,y:ny}]);
        }
    }
    return bestPath?bestPath.slice(1):null;
}

// Определение безопасного пути к яблоку
function findPath(){
    let path = aStar(snake[0], apple, snake);
    if(!path || !safePath(null, path)){
        // попробуем reversed A*
        path = reversedAStar(snake[0], apple, snake);
        if(!path || !safePath(null, path)){
            survivalMode = true; // активируем выживание
            return null;
        } else {
            survivalMode = false;
            return path;
        }
    } else {
        survivalMode = false;
        return path;
    }
}

// Рисуем всё
function draw(){
    ctx.fillStyle = "#151515";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    
    // змейка
    ctx.fillStyle = survivalMode ? snakeColorSurvival : snakeColorNormal;
    for(let s of snake){
        ctx.fillRect(s.x*GRID_SIZE + (GRID_SIZE-SNAKE_SIZE)/2,
                     s.y*GRID_SIZE + (GRID_SIZE-SNAKE_SIZE)/2,
                     SNAKE_SIZE, SNAKE_SIZE);
    }
    
    // яблоко
    ctx.fillStyle = appleColor;
    ctx.fillRect(apple.x*GRID_SIZE + (GRID_SIZE-APPLE_SIZE)/2,
                 apple.y*GRID_SIZE + (GRID_SIZE-APPLE_SIZE)/2,
                 APPLE_SIZE, APPLE_SIZE);
}

// логика движения
let path = [];
function update(){
    if(!path || path.length===0){
        path = findPath();
    }
    
    if(path && path.length>0){
        let next = path.shift();
        snake.unshift(next);
        if(next.x===apple.x && next.y===apple.y){
            // новое яблоко
            do{
                apple = {x:Math.floor(Math.random()*GRID_WIDTH), y:Math.floor(Math.random()*GRID_HEIGHT)};
            }while(snake.some(s=>s.x===apple.x && s.y===apple.y));
            path = findPath(); // пересчёт пути
        } else {
            snake.pop();
        }
    } else if(survivalMode){
        // простой survival: идём за хвостом
        let tail = snake[snake.length-1];
        let dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
        for(let d of dirs){
            let nx = snake[0].x + d.x;
            let ny = snake[0].y + d.y;
            if(nx<0 || ny<0 || nx>=GRID_WIDTH || ny>=GRID_HEIGHT) continue;
            if(!snake.some(s=>s.x===nx && s.y===ny)){
                snake.unshift({x:nx,y:ny});
                snake.pop();
                break;
            }
        }
        path = findPath(); // проверяем, доступен ли путь к яблоку
    }
    
    draw();
}

setInterval(update, 150);
</script>
</body>
</html>
