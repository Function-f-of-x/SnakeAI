<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake AI</title>
<style>
  body { margin:0; background:#000000; display:flex; justify-content:center; align-items:center; height:100vh; }
  canvas { background:#151515; display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const GRID_SIZE = 54;
const CELL_SIZE = 48;
const PADDING = GRID_SIZE - CELL_SIZE;

const COLS = 10;
const ROWS = 10;
const TOTAL_CELLS = COLS * ROWS;

canvas.width = COLS * GRID_SIZE;
canvas.height = ROWS * GRID_SIZE;

let snake = [{x:5, y:5}];
let apple = spawnApple();
let path = [];
let survival = false;
let gameOver = false;

function spawnApple() {
    let pos;
    do {
        pos = {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
    } while(snake.some(s => s.x===pos.x && s.y===pos.y));
    return pos;
}

function draw() {
    ctx.fillStyle = '#151515';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Apple
    ctx.fillStyle = '#ee0a17';
    ctx.fillRect(apple.x*GRID_SIZE + (GRID_SIZE-51)/2, apple.y*GRID_SIZE + (GRID_SIZE-51)/2, 51,51);

    // Snake
    ctx.fillStyle = gameOver ? '#808080' : (survival ? '#b20c18' : '#3ac322');
    snake.forEach(s => {
        ctx.fillRect(s.x*GRID_SIZE + (GRID_SIZE-CELL_SIZE)/2, s.y*GRID_SIZE + (GRID_SIZE-CELL_SIZE)/2, CELL_SIZE, CELL_SIZE);
    });
}

function neighbors(node){
    const deltas = [
        {x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}
    ];
    return deltas.map(d=>({x: node.x+d.x, y: node.y+d.y}))
                 .filter(n=>n.x>=0 && n.x<COLS && n.y>=0 && n.y<ROWS)
                 .filter(n=>!snake.some(s=>s.x===n.x && s.y===n.y));
}

function heuristic(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }

// Обычный A* с проверкой 80% доступных клеток
function findPath() {
    const start = snake[0];
    const goal = apple;
    let open = [{node:start, g:0, f:heuristic(start,goal), parent:null}];
    let closed = [];

    while(open.length>0){
        open.sort((a,b)=>a.f-b.f);
        const current = open.shift();

        if(current.node.x===goal.x && current.node.y===goal.y){
            let p = [];
            let c = current;
            while(c){
                p.unshift(c.node);
                c = c.parent;
            }
            p.shift();

            const futureSnake = [...snake, ...p];
            if(reachableCells(futureSnake[0], futureSnake) >= Math.floor(0.8*(COLS*ROWS - futureSnake.length))){
                return p;
            } else {
                continue;
            }
        }

        closed.push(current.node);
        for(const n of neighbors(current.node)){
            if(closed.some(c=>c.x===n.x && c.y===n.y)) continue;
            let g = current.g+1;
            let f = g + heuristic(n,goal);
            if(open.some(o=>o.node.x===n.x && o.node.y===n.y && o.f<=f)) continue;
            open.push({node:n,g,f,parent:current});
        }
    }
    return null;
}

// Reversed A* — ищет длиннейший безопасный путь
function reversedAStar() {
    const start = snake[0];
    const goal = apple;
    let open = [{node:start, g:0, f:heuristic(goal,start), parent:null}];
    let closed = [];
    let longestPath = null;

    while(open.length>0){
        open.sort((a,b)=>b.f-a.f); // отдаём приоритет удалению от яблока
        const current = open.shift();

        if(current.node.x===goal.x && current.node.y===goal.y){
            let p = [];
            let c = current;
            while(c){
                p.unshift(c.node);
                c = c.parent;
            }
            p.shift();

            const futureSnake = [...snake, ...p];
            if(reachableCells(futureSnake[0], futureSnake) >= Math.floor(0.8*(COLS*ROWS - futureSnake.length))){
                if(!longestPath || p.length > longestPath.length) longestPath = p;
            }
            continue;
        }

        closed.push(current.node);

        for(const n of neighbors(current.node)){
            if(closed.some(c=>c.x===n.x && c.y===n.y)) continue;
            let g = current.g+1;
            let f = g + heuristic(goal,n);
            if(open.some(o=>o.node.x===n.x && o.node.y===n.y && o.f>=f)) continue;
            open.push({node:n,g,f,parent:current});
        }
    }

    return longestPath;
}

// BFS для подсчёта доступных клеток
function reachableCells(startPos, occupied) {
    const queue = [startPos];
    const visited = new Set([`${startPos.x},${startPos.y}`]);
    let count = 1;

    while(queue.length>0){
        const cur = queue.shift();
        for(const n of neighbors(cur)){
            if(!visited.has(`${n.x},${n.y}`) && !occupied.some(s=>s.x===n.x && s.y===n.y)){
                queue.push(n);
                visited.add(`${n.x},${n.y}`);
                count++;
            }
        }
    }
    return count;
}

function update() {
    if(gameOver) return;

    const lengthThreshold = Math.floor(TOTAL_CELLS/8);

    if(!path || path.length===0){
        let chosenPath = null;

        if(snake.length <= lengthThreshold){
            chosenPath = findPath();
            survival=false;
        } else {
            chosenPath = reversedAStar();
            survival=false;
        }

        if(!chosenPath){
            // Survival mode
            survival=true;
            const tail = snake[snake.length-1];
            let freeNeighbors = neighbors(snake[0]);
            if(freeNeighbors.length>0) chosenPath = [freeNeighbors[0]];
            else chosenPath = [tail];
        }

        path = chosenPath;
    }

    if(path.length>0){
        let next = path.shift();

        // Check collision
        if(snake.some(s=>s.x===next.x && s.y===next.y)){
            gameOver = true;
            return;
        }

        snake.unshift(next);

        if(next.x===apple.x && next.y===apple.y){
            apple = spawnApple();
            path=[];
        } else {
            snake.pop();
        }
    }
}

function gameLoop(){
    update();
    draw();
    setTimeout(gameLoop, 200);
}

gameLoop();
</script>
</body>
</html>
