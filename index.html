<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake AI — Smart Paths</title>
<style>
  body { margin:0; background:#000000; display:flex; justify-content:center; align-items:center; height:100vh; }
  canvas { background:#151515; display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const GRID_SIZE = 54;
const CELL_SIZE = 48;

const COLS = 10;
const ROWS = 10;
const TOTAL_CELLS = COLS * ROWS;

canvas.width = COLS * GRID_SIZE;
canvas.height = ROWS * GRID_SIZE;

let snake = [{x:5, y:5}];
let apple = spawnApple();
let path = [];
let survival = false;
let gameOver = false;

function spawnApple(){
    let pos;
    do {
        pos = {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
    } while(snake.some(s=>s.x===pos.x && s.y===pos.y));
    return pos;
}

function draw(){
    ctx.fillStyle = '#151515';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // apple
    ctx.fillStyle = '#ee0a17';
    ctx.fillRect(apple.x*GRID_SIZE + (GRID_SIZE-51)/2, apple.y*GRID_SIZE + (GRID_SIZE-51)/2, 51, 51);

    // snake
    ctx.fillStyle = gameOver ? '#808080' : (survival ? '#b20c18' : '#3ac322');
    snake.forEach(s=>{
        ctx.fillRect(s.x*GRID_SIZE + (GRID_SIZE-CELL_SIZE)/2, s.y*GRID_SIZE + (GRID_SIZE-CELL_SIZE)/2, CELL_SIZE, CELL_SIZE);
    });
}

function neighbors(node, snakeOverride=snake){
    const deltas = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
    return deltas.map(d=>({x: node.x+d.x, y: node.y+d.y}))
                 .filter(n=>n.x>=0 && n.x<COLS && n.y>=0 && n.y<ROWS)
                 .filter(n=>!snakeOverride.some(s=>s.x===n.x && s.y===n.y));
}

function heuristic(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }

// BFS для проверки 80%
function bfs(startPos, occupied){
    let queue=[startPos], visited=new Set([`${startPos.x},${startPos.y}`]), count=1;
    while(queue.length>0){
        let cur = queue.shift();
        for(let d of [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}]){
            let nx=cur.x+d.x, ny=cur.y+d.y;
            if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
            if(occupied.some(s=>s.x===nx&&s.y===ny)) continue;
            const key=`${nx},${ny}`;
            if(!visited.has(key)){
                visited.add(key);
                queue.push({x:nx,y:ny});
                count++;
            }
        }
    }
    return count;
}

function checkSafePath(path){
    if(!path) return false;
    let futureSnake = [...snake];
    for(let step of path){
        futureSnake.unshift(step);
        if(step.x===apple.x && step.y===apple.y) break;
        else futureSnake.pop();
    }
    const reachable = bfs(futureSnake[0], futureSnake);
    const emptyCells = COLS*ROWS - futureSnake.length;
    return reachable >= Math.floor(0.8*emptyCells);
}

// обычный A*
function aStar(){
    const start = snake[0];
    const goal = apple;
    let open=[{node:start,g:0,f:heuristic(start,goal),parent:null}];
    let closed=[];

    while(open.length>0){
        open.sort((a,b)=>a.f-b.f);
        const current=open.shift();
        if(current.node.x===goal.x && current.node.y===goal.y){
            let p=[],c=current;
            while(c){p.unshift(c.node);c=c.parent;}
            return checkSafePath(p.slice(1))?p.slice(1):null;
        }
        closed.push(current.node);
        for(const n of neighbors(current.node)){
            if(closed.some(c=>c.x===n.x&&c.y===n.y)) continue;
            let g=current.g+1;
            let f=g+heuristic(n,goal);
            if(open.some(o=>o.node.x===n.x&&o.node.y===n.y&&o.f<=f)) continue;
            open.push({node:n,g,f,parent:current});
        }
    }
    return null;
}

// reversed A* (длиннейший путь)
function reversedAStar(){
    const start = snake[0];
    const goal = apple;
    let open=[{node:start,g:0,f:heuristic(start,goal),parent:null}];
    let closed=[];
    let best=null;

    while(open.length>0){
        open.sort((a,b)=>b.f-a.f);
        const current=open.shift();
        if(current.node.x===goal.x && current.node.y===goal.y){
            let p=[],c=current;
            while(c){p.unshift(c.node);c=c.parent;}
            if(!best || p.length>best.length) best=p;
            continue;
        }
        closed.push(current.node);
        for(const n of neighbors(current.node)){
            if(closed.some(c=>c.x===n.x&&c.y===n.y)) continue;
            let g=current.g+1;
            let f=g+heuristic(n,goal);
            if(open.some(o=>o.node.x===n.x&&o.node.y===n.y&&o.f>=f)) continue;
            open.push({node:n,g,f,parent:current});
        }
    }
    return best && checkSafePath(best.slice(1)) ? best.slice(1) : null;
}

function survivalMove(){
    let free = neighbors(snake[0]);
    for(let n of free){
        let testSnake=[n,...snake];
        testSnake.pop();
        const reachable=bfs(n,testSnake);
        const emptyCells=COLS*ROWS-testSnake.length;
        if(reachable>=Math.floor(0.8*emptyCells)) return [n];
    }
    return free.length>0?[free[0]]:null;
}

function update(){
    if(gameOver) return;

    if(!path || path.length===0){
        let chosen=null;
        let threshold=Math.floor(TOTAL_CELLS/8);
        if(snake.length < threshold) chosen=aStar();
        else chosen=reversedAStar();
        if(!chosen){
            survival=true;
            chosen=survivalMove();
        } else survival=false;
        if(!chosen){gameOver=true;return;}
        path=chosen;
    }

    let next=path.shift();
    if(snake.some(s=>s.x===next.x&&s.y===next.y)){gameOver=true;return;}
    snake.unshift(next);
    if(next.x===apple.x && next.y===apple.y){
        apple=spawnApple();
        path=[];
    } else snake.pop();
}

function gameLoop(){
    update();
    draw();
    setTimeout(gameLoop,200);
}

gameLoop();
</script>
</body>
</html>
