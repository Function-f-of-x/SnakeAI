<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake AI Survival</title>
<style>
body {
  margin: 0;
  background: #151515;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
canvas {
  background: #151515;
}
</style>
</head>
<body>
<canvas id="game" width="1080" height="1080"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const GRID_SIZE = 54;
const SNAKE_SIZE = 48;
const APPLE_SIZE = 51;
const GAP = GRID_SIZE - SNAKE_SIZE;

const ROWS = canvas.height / GRID_SIZE | 0;
const COLS = canvas.width / GRID_SIZE | 0;

let snake = [{x: Math.floor(COLS/2), y: Math.floor(ROWS/2)}];
let apple = spawnApple();
let direction = {x:0,y:0};
let survivalMode = false;

// Colors
const SNAKE_COLOR = "#3ac322";
const SURVIVAL_COLOR = "#b20c18";
const APPLE_COLOR = "#e9102";

// Game loop
function gameLoop() {
    survivalMode = !astarPathToApple();
    moveSnake();
    draw();
    setTimeout(gameLoop, 50);
}

// Drawing
function draw() {
    ctx.fillStyle = "#151515";
    ctx.fillRect(0,0,canvas.width, canvas.height);

    // Draw apple
    ctx.fillStyle = APPLE_COLOR;
    ctx.fillRect(apple.x*GRID_SIZE + (GRID_SIZE-APPLE_SIZE)/2,
                 apple.y*GRID_SIZE + (GRID_SIZE-APPLE_SIZE)/2,
                 APPLE_SIZE, APPLE_SIZE);

    // Draw snake
    for(let i=0;i<snake.length;i++){
        ctx.fillStyle = survivalMode ? SURVIVAL_COLOR : SNAKE_COLOR;
        ctx.fillRect(snake[i].x*GRID_SIZE,
                     snake[i].y*GRID_SIZE,
                     SNAKE_SIZE, SNAKE_SIZE);
    }
}

// Snake movement
function moveSnake(){
    let next;
    if(survivalMode){
        next = survivalMove();
    } else {
        next = astarMove();
    }
    if(!next) return; // trapped

    snake.unshift(next);
    if(next.x===apple.x && next.y===apple.y){
        apple = spawnApple();
    } else {
        snake.pop();
    }
}

// Spawn apple
function spawnApple() {
    while(true){
        let x = Math.floor(Math.random()*COLS);
        let y = Math.floor(Math.random()*ROWS);
        if(!snake.some(s=>s.x===x && s.y===y)) return {x,y};
    }
}

// --- Algorithms ---

// Check if path exists from head to apple (A* simplified)
function astarPathToApple(){
    let head = snake[0];
    let open = [head];
    let visited = new Set();
    let snakeSet = new Set(snake.map(s=>s.x+","+s.y));
    while(open.length>0){
        let curr = open.shift();
        if(curr.x===apple.x && curr.y===apple.y) return true;
        visited.add(curr.x+","+curr.y);
        let neighbors = [
            {x:curr.x+1,y:curr.y},
            {x:curr.x-1,y:curr.y},
            {x:curr.x,y:curr.y+1},
            {x:curr.x,y:curr.y-1}
        ];
        for(let n of neighbors){
            let key = n.x+","+n.y;
            if(n.x<0||n.x>=COLS||n.y<0||n.y>=ROWS) continue;
            if(visited.has(key)) continue;
            if(snakeSet.has(key)) continue;
            open.push(n);
        }
    }
    return false;
}

// Standard A* movement (toward apple)
function astarMove(){
    let head = snake[0];
    let dx = apple.x - head.x;
    let dy = apple.y - head.y;
    let nx = head.x + Math.sign(dx);
    let ny = head.y + Math.sign(dy);
    if(validMove(nx,ny)) return {x:nx,y:ny};
    return alternativeMove(head);
}

// Survival mode movement (follow tail / avoid trapping)
function survivalMove(){
    let head = snake[0];
    let moves = [
        {x:head.x+1,y:head.y},
        {x:head.x-1,y:head.y},
        {x:head.x,y:head.y+1},
        {x:head.x,y:head.y-1}
    ];
    moves = moves.filter(m=>validMove(m.x,m.y));
    moves = moves.filter(m=>reachableSpace(m)>=0.8*(ROWS*COLS - snake.length));
    if(moves.length===0) return alternativeMove(head);
    // If path to apple appears, go to apple
    if(astarPathToApple()){
        return astarMove();
    }
    // Else, choose move that maximizes reachable space
    moves.sort((a,b)=>reachableSpace(b)-reachableSpace(a));
    return moves[0];
}

// Calculate how many empty squares reachable from a point
function reachableSpace(start){
    let visited = new Set();
    let stack = [start];
    let snakeSet = new Set(snake.map(s=>s.x+","+s.y));
    while(stack.length>0){
        let curr = stack.pop();
        let key = curr.x+","+curr.y;
        if(visited.has(key)) continue;
        visited.add(key);
        let dirs = [
            {x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}
        ];
        for(let d of dirs){
            let nx = curr.x+d.x, ny = curr.y+d.y;
            let nKey = nx+","+ny;
            if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
            if(visited.has(nKey)) continue;
            if(snakeSet.has(nKey)) continue;
            stack.push({x:nx,y:ny});
        }
    }
    return visited.size;
}

// Helpers
function validMove(x,y){
    if(x<0 || x>=COLS || y<0 || y>=ROWS) return false;
    if(snake.some(s=>s.x===x && s.y===y)) return false;
    return true;
}

function alternativeMove(head){
    let dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
    for(let d of dirs){
        let nx = head.x+d.x, ny = head.y+d.y;
        if(validMove(nx,ny)) return {x:nx,y:ny};
    }
    return head; // trapped
}

gameLoop();
</script>
</body>
</html>
