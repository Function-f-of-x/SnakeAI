<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake AI</title>
<style>
    body {
        margin: 0;
        background: #151515;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        user-select: none;
    }
    canvas {
        display: block;
        background: #151515;
    }
</style>
</head>
<body>
<canvas id="game" width="972" height="972"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const GRID = 54;
const CELL = 48; // клетка змейки
const APPLE = 51; // яблоко

const ROWS = canvas.height / GRID;
const COLS = canvas.width / GRID;

let snake = [{x:0,y:0}];
let direction = {x:1,y:0};
let apple = {x:10,y:10};
let mode = 'aStar'; // aStar, reversed, hamiltonian
let survivalMode = false;

// Генерация яблока
function spawnApple() {
    do {
        apple.x = Math.floor(Math.random()*COLS);
        apple.y = Math.floor(Math.random()*ROWS);
    } while(snake.some(s => s.x===apple.x && s.y===apple.y));
}

// Проверка допустимого хода
function validMove(x,y){
    return x>=0 && x<COLS && y>=0 && y<ROWS && !snake.some(s=>s.x===x && s.y===y);
}

// Проверка на survival-safe
function survivalSafe(cell){
    // вычисляем reachable зоны после хода
    let reachable = floodFill(cell.x, cell.y);
    return reachable/snake.length > 0.8; // базово
}

// Flood fill для survival mode
function floodFill(x,y){
    let visited = Array(ROWS).fill().map(()=>Array(COLS).fill(false));
    let stack = [{x,y}];
    let count = 0;
    while(stack.length){
        let c = stack.pop();
        if(c.x<0||c.x>=COLS||c.y<0||c.y>=ROWS) continue;
        if(visited[c.y][c.x]) continue;
        if(snake.some(s=>s.x===c.x && s.y===c.y)) continue;
        visited[c.y][c.x]=true;
        count++;
        stack.push({x:c.x+1,y:c.y});
        stack.push({x:c.x-1,y:c.y});
        stack.push({x:c.x,y:c.y+1});
        stack.push({x:c.x,y:c.y-1});
    }
    return count;
}

// A* простой поиск
function aStar(start,end){
    let open = [{pos:start,f:0,g:0,h:0,parent:null}];
    let closed = [];
    while(open.length){
        open.sort((a,b)=>a.f-b.f);
        let current = open.shift();
        if(current.pos.x===end.x && current.pos.y===end.y){
            let path=[];
            while(current){path.unshift(current.pos); current=current.parent;}
            return path;
        }
        closed.push(current.pos);
        let moves=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
        for(let m of moves){
            let nx = current.pos.x+m.x;
            let ny = current.pos.y+m.y;
            if(!validMove(nx,ny) || closed.some(c=>c.x===nx&&c.y===ny)) continue;
            let g = current.g+1;
            let h = Math.abs(nx-end.x)+Math.abs(ny-end.y);
            let f = g+h;
            if(open.some(o=>o.pos.x===nx && o.pos.y===ny && o.f<=f)) continue;
            open.push({pos:{x:nx,y:ny},f,g,h,parent:current});
        }
    }
    return null;
}

// Reversed A* + survival
function reversedMove(){
    let head = snake[0];
    let moves=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
    let safeMoves = moves.filter(m=>{
        let nx=head.x+m.x, ny=head.y+m.y;
        return validMove(nx,ny) && survivalSafe({x:nx,y:ny});
    });
    if(safeMoves.length>0){
        return safeMoves[Math.floor(Math.random()*safeMoves.length)];
    }
    // fallback
    for(let m of moves){
        let nx=head.x+m.x, ny=head.y+m.y;
        if(validMove(nx,ny)) return m;
    }
    return {x:0,y:0};
}

// Hamiltonian cycle
function hamiltonianMove(){
    // простая змейка-зигзаг, без сокращений
    let head = snake[0];
    if(head.y%2===0){
        if(head.x<COLS-1) return {x:1,y:0};
        else return {x:0,y:1};
    } else {
        if(head.x>0) return {x:-1,y:0};
        else return {x:0,y:1};
    }
}

// Основной шаг
function step(){
    let move;
    if(snake.length<20) { // маленькая змейка
        let path=aStar(snake[0],apple);
        if(path && path.length>1){
            move={x:path[1].x-snake[0].x,y:path[1].y-snake[0].y};
        } else move={x:0,y:0};
        survivalMode=false;
    } else if(snake.length<80) { // средняя
        move=reversedMove();
        survivalMode=true;
    } else { // большая
        move=hamiltonianMove();
        survivalMode=false;
    }
    let newHead={x:snake[0].x+move.x,y:snake[0].y+move.y};
    if(!validMove(newHead.x,newHead.y)) return false;
    snake.unshift(newHead);
    if(newHead.x===apple.x && newHead.y===apple.y){
        spawnApple();
    } else snake.pop();
    return true;
}

// Рисуем всё
function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // сетка
    for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
            ctx.strokeStyle="#151515";
            ctx.strokeRect(x*GRID,y*GRID,GRID,GRID);
        }
    }
    // яблоко
    ctx.fillStyle="#e9102";
    ctx.fillRect(apple.x*GRID+(GRID-APPLE)/2,apple.y*GRID+(GRID-APPLE)/2,APPLE,APPLE);
    // змейка
    for(let i=0;i<snake.length;i++){
        ctx.fillStyle=survivalMode?"#b20c18":"#3ac322";
        ctx.fillRect(snake[i].x*GRID+(GRID-CELL)/2,snake[i].y*GRID+(GRID-CELL)/2,CELL,CELL);
    }
}

// Игровой цикл
function gameLoop(){
    if(!step()) { alert("Game Over"); return; }
    draw();
    setTimeout(gameLoop,50);
}

spawnApple();
gameLoop();

</script>
</body>
</html>
