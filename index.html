<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake AI</title>
<style>
  body { margin:0; background:#151515; display:flex; justify-content:center; align-items:center; height:100vh; }
  canvas { background:#151515; display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const GRID_SIZE = 54;
const SNAKE_SIZE = 48;
const APPLE_SIZE = 51;

const COLS = 10;
const ROWS = 10;

const NORMAL_COLOR = "#3ac322";
const SURVIVAL_COLOR = "#b20c18";
const APPLE_COLOR = "#ee0a17";

const canvas = document.getElementById('game');
canvas.width = GRID_SIZE * COLS;
canvas.height = GRID_SIZE * ROWS;
const ctx = canvas.getContext('2d');

let snake = [{x:5,y:5}];
let apple = {x:2, y:3};
let direction = {x:0, y:0};
let survivalMode = false;

function draw(){
    ctx.fillStyle = "#151515";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // яблоко
    ctx.fillStyle = APPLE_COLOR;
    ctx.fillRect(
        apple.x*GRID_SIZE + (GRID_SIZE-APPLE_SIZE)/2,
        apple.y*GRID_SIZE + (GRID_SIZE-APPLE_SIZE)/2,
        APPLE_SIZE, APPLE_SIZE
    );

    // змейка
    ctx.fillStyle = survivalMode ? SURVIVAL_COLOR : NORMAL_COLOR;
    for(let i=0;i<snake.length;i++){
        let s = snake[i];
        ctx.fillRect(
            s.x*GRID_SIZE + (GRID_SIZE-SNAKE_SIZE)/2,
            s.y*GRID_SIZE + (GRID_SIZE-SNAKE_SIZE)/2,
            SNAKE_SIZE, SNAKE_SIZE
        );
    }
}

// проверка валидного хода
function validMove(x,y){
    if(x<0||y<0||x>=COLS||y>=ROWS) return false;
    for(let seg of snake) if(seg.x===x && seg.y===y) return false;
    return true;
}

// BFS для проверки досягаемости 80% пустых клеток
function reachableSpace(head){
    let visited = Array.from({length:ROWS},()=>Array(COLS).fill(false));
    let queue = [head];
    visited[head.y][head.x]=true;
    let count = 1;
    while(queue.length){
        let {x,y} = queue.shift();
        let moves = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
        for(let m of moves){
            let nx = x + m.x, ny = y + m.y;
            if(nx>=0 && ny>=0 && nx<COLS && ny<ROWS && !visited[ny][nx] && validMove(nx,ny)){
                visited[ny][nx]=true;
                queue.push({x:nx,y:ny});
                count++;
            }
        }
    }
    return count;
}

// простейший A* и Reversed A* (по расстоянию)
function findPath(head,target,reversed=false){
    let dx = target.x - head.x;
    let dy = target.y - head.y;
    let moveOptions = [];

    // survival: если путь к яблоку недоступен, режим выживания
    let reach = reachableSpace(head);
    survivalMode = reach < Math.floor(0.8 * (COLS*ROWS - snake.length));

    // если survival, просто ищем безопасный ход по очереди
    if(survivalMode){
        let moves = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
        for(let m of moves){
            let nx = head.x + m.x;
            let ny = head.y + m.y;
            if(validMove(nx,ny)) return {x:nx, y:ny};
        }
        return head; // тупик
    }

    // обычный A* / Reversed A* (по оси X или Y)
    if(reversed) { dx*=-1; dy*=-1; }

    if(Math.abs(dx) >= Math.abs(dy)){
        let nx = head.x + Math.sign(dx);
        if(validMove(nx,head.y)) return {x:nx, y:head.y};
    }
    if(dy!==0){
        let ny = head.y + Math.sign(dy);
        if(validMove(head.x,ny)) return {x:head.x, y:ny};
    }

    // если прямого хода нет, пробуем любое допустимое
    let moves = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
    for(let m of moves){
        let nx = head.x + m.x;
        let ny = head.y + m.y;
        if(validMove(nx,ny)) return {x:nx, y:ny};
    }

    return head; // тупик
}

function update(){
    let head = snake[0];

    // выбираем стратегию
    let newHead;
    if(snake.length < 5){
        newHead = findPath(head,apple,false); // маленькая змейка A*
    } else {
        newHead = findPath(head,apple,true); // средняя Reversed A*
    }

    snake.unshift(newHead);

    // проверка поедания яблока
    if(newHead.x===apple.x && newHead.y===apple.y){
        // новое яблоко случайно
        do {
            apple = {x:Math.floor(Math.random()*COLS),y:Math.floor(Math.random()*ROWS)};
        } while(!validMove(apple.x,apple.y));
    } else {
        snake.pop();
    }

    draw();
}

setInterval(update,200);
</script>
</body>
</html>
