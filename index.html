<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Snake AI</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body { margin: 0; background: black; }
    canvas { display: block; margin: auto; }
  </style>
</head>
<body>
<script>
let rez = 20;
let snake;
let food;
let cols, rows;

function setup() {
  createCanvas(600, 600);
  frameRate(15);
  cols = floor(width / rez);
  rows = floor(height / rez);
  snake = new Snake();
  food = new Food();
}

function draw() {
  background(0);
  snake.update();
  snake.show();
  food.show();
}

class Snake {
  constructor() {
    this.body = [createVector(floor(cols / 2), floor(rows / 2))];
    this.len = 1;
    this.dir = createVector(0, 0);
  }

  update() {
    if (this.body.length === 0) return;

    let head = this.body[this.body.length - 1].copy();

    // Решение куда двигаться
    let path;
    if (this.body.length < (cols * rows) / 8) {
      path = aStar(this.getMaze(), head, food.pos);
    } else {
      path = reversedAStar(this.getMaze(), head, food.pos);
      if (!path || !this.survivalCheck(path)) {
        path = aStar(this.getMaze(), head, food.pos);
      }
    }

    if (path && path.length > 1) {
      head = path[1].copy();
    }

    // Проверка на яблоко
    if (head.equals(food.pos)) {
      this.body.push(head);
      this.len++;
      food = new Food();
    } else {
      this.body.shift();
      this.body.push(head);
    }
  }

  getMaze() {
    let maze = Array(rows).fill().map(() => Array(cols).fill(0));
    for (let p of this.body) {
      maze[p.y][p.x] = 1;
    }
    return maze;
  }

  survivalCheck(path) {
    let sim = this.body.map(v => v.copy());
    let head = sim[sim.length - 1].copy();
    for (let i = 1; i < path.length; i++) {
      head = path[i].copy();
      sim.push(head);
      if (sim.length > this.len + 1) sim.shift();
    }
    return sim.length >= 0.8 * cols * rows;
  }

  show() {
    for (let i = 0; i < this.body.length; i++) {
      fill(i === this.body.length - 1 ? "#00FF00" : "#00AAFF");
      noStroke();
      rect(this.body[i].x * rez, this.body[i].y * rez, rez, rez);
    }
  }
}

class Food {
  constructor() {
    this.pos = this.randomPos();
  }
  randomPos() {
    return createVector(floor(random(cols)), floor(random(rows)));
  }
  show() {
    fill("#FF0000");
    noStroke();
    rect(this.pos.x * rez, this.pos.y * rez, rez, rez);
  }
}

// A* минимальный путь
function aStar(maze, start, end) {
  let open = [];
  let closed = [];
  open.push({pos: start, g:0, f:heuristic(start,end), parent:null});

  while (open.length > 0) {
    let current = open.reduce((a,b) => a.f < b.f ? a : b);
    if (current.pos.equals(end)) {
      let path = [];
      while (current) {
        path.unshift(current.pos);
        current = current.parent;
      }
      return path;
    }
    open = open.filter(n => n !== current);
    closed.push(current);

    for (let n of neighbors(current.pos)) {
      if (maze[n.y][n.x] === 1 && !(n.equals(end))) continue;
      if (closed.find(c => c.pos.equals(n))) continue;
      let g = current.g + 1;
      let existing = open.find(o => o.pos.equals(n));
      if (!existing) {
        open.push({pos:n, g:g, f:g+heuristic(n,end), parent:current});
      } else if (g < existing.g) {
        existing.g = g;
        existing.f = g + heuristic(n,end);
        existing.parent = current;
      }
    }
  }
  return null;
}

// Reversed A* (ищет длинный путь)
function reversedAStar(maze, start, end) {
  let open = [];
  let closed = [];
  open.push({pos:start, g:0, f:-heuristic(start,end), parent:null});
  let best = null;

  while (open.length > 0) {
    let current = open.reduce((a,b) => a.f > b.f ? a : b);
    if (current.pos.equals(end)) {
      best = current;
      break;
    }
    open = open.filter(n => n !== current);
    closed.push(current);

    for (let n of neighbors(current.pos)) {
      if (maze[n.y][n.x] === 1 && !(n.equals(end))) continue;
      if (closed.find(c => c.pos.equals(n))) continue;
      let g = current.g + 1;
      let existing = open.find(o => o.pos.equals(n));
      if (!existing) {
        open.push({pos:n, g:g, f:g-heuristic(n,end), parent:current});
      } else if (g > existing.g) { // отличие: ищем длиннее
        existing.g = g;
        existing.f = g - heuristic(n,end);
        existing.parent = current;
      }
    }
  }

  if (!best) return null;
  let path = [];
  while (best) {
    path.unshift(best.pos);
    best = best.parent;
  }
  return path;
}

function heuristic(a,b) {
  return abs(a.x-b.x) + abs(a.y-b.y);
}

function neighbors(pos) {
  let dirs = [createVector(1,0), createVector(-1,0), createVector(0,1), createVector(0,-1)];
  let result = [];
  for (let d of dirs) {
    let nx = pos.x + d.x, ny = pos.y + d.y;
    if (nx>=0 && ny>=0 && nx<cols && ny<rows) {
      result.push(createVector(nx,ny));
    }
  }
  return result;
}
</script>
</body>
</html>
