<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake AI</title>
<style>
  body { margin:0; background:#000000; display:flex; justify-content:center; align-items:center; height:100vh; }
  canvas { background:#151515; display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const GRID_SIZE = 54;
const CELL_SIZE = 48;
const PADDING = GRID_SIZE - CELL_SIZE;

const COLS = 10;
const ROWS = 10;
const TOTAL_CELLS = COLS*ROWS;

canvas.width = COLS * GRID_SIZE;
canvas.height = ROWS * GRID_SIZE;

let snake = [{x:5, y:5}];
let apple = spawnApple();
let path = [];
let survival = false;
let gameOver = false;

function spawnApple() {
    let pos;
    do {
        pos = {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
    } while(snake.some(s => s.x===pos.x && s.y===pos.y));
    return pos;
}

function draw() {
    ctx.fillStyle = '#151515';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Draw apple
    ctx.fillStyle = '#ee0a17';
    ctx.fillRect(apple.x*GRID_SIZE + (GRID_SIZE-51)/2, apple.y*GRID_SIZE + (GRID_SIZE-51)/2, 51,51);

    // Draw snake
    ctx.fillStyle = gameOver ? '#808080' : (survival ? '#b20c18' : '#3ac322');
    snake.forEach(s => {
        ctx.fillRect(s.x*GRID_SIZE + (GRID_SIZE-CELL_SIZE)/2, s.y*GRID_SIZE + (GRID_SIZE-CELL_SIZE)/2, CELL_SIZE, CELL_SIZE);
    });
}

function neighbors(node){
    const deltas = [
        {x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}
    ];
    return deltas.map(d=>({x: node.x+d.x, y: node.y+d.y}))
                 .filter(n=>n.x>=0 && n.x<COLS && n.y>=0 && n.y<ROWS)
                 .filter(n=>!snake.some(s=>s.x===n.x && s.y===n.y));
}

function heuristic(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }

function findPath() {
    const start = snake[0];
    const goal = apple;
    let open = [{node:start, g:0, f:heuristic(start,goal), parent:null}];
    let closed = [];

    while(open.length>0){
        open.sort((a,b)=>a.f-b.f);
        const current = open.shift();
        if(current.node.x===goal.x && current.node.y===goal.y){
            let p = [];
            let c = current;
            while(c){
                p.unshift(c.node);
                c = c.parent;
            }
            return p.slice(1);
        }
        closed.push(current.node);
        for(const n of neighbors(current.node)){
            if(closed.some(c=>c.x===n.x && c.y===n.y)) continue;
            let g = current.g+1;
            let f = g + heuristic(n,goal);
            if(open.some(o=>o.node.x===n.x && o.node.y===n.y && o.f<=f)) continue;
            open.push({node:n,g,f,parent:current});
        }
    }
    return null;
}

function safePath(pathToCheck){
    if(!pathToCheck) return false;
    const futureSnake = [...snake];
    pathToCheck.forEach(p=>futureSnake.unshift(p));
    let reachable = bfs(futureSnake[0], futureSnake);
    const emptyCells = COLS*ROWS - futureSnake.length;
    return reachable >= Math.floor(0.8*emptyCells);
}

function bfs(startPos, occupied){
    let queue=[startPos], visited=[`${startPos.x},${startPos.y}`], count=1;
    while(queue.length>0){
        let cur = queue.shift();
        for(let n of neighbors(cur)){
            if(!visited.includes(`${n.x},${n.y}`) && !occupied.some(s=>s.x===n.x && s.y===n.y)){
                queue.push(n);
                visited.push(`${n.x},${n.y}`);
                count++;
            }
        }
    }
    return count;
}

function reversedAStar(grid, start, goal) {
    const width = grid[0].length;
    const height = grid.length;

    // создаём очередь для BFS с приоритетом длинного пути
    let queue = [{ pos: start, path: [start] }];
    let visited = Array.from({ length: height }, () => Array(width).fill(false));
    visited[start.y][start.x] = true;

    let longestPath = null;

    while (queue.length > 0) {
        // достаём последний элемент, чтобы идти «длинным» путем
        let current = queue.pop();
        let { pos, path } = current;

        if (pos.x === goal.x && pos.y === goal.y) {
            // если путь к яблоку найден, сохраняем его только если он длиннее текущего
            if (!longestPath || path.length > longestPath.length) {
                longestPath = path;
            }
            continue; // не останавливаемся — ищем более длинный
        }

        // смещения по 4 направлениям (без диагоналей)
        const dirs = [
            { x: 0, y: -1 }, // вверх
            { x: 1, y: 0 },  // вправо
            { x: 0, y: 1 },  // вниз
            { x: -1, y: 0 }  // влево
        ];

        for (let d of dirs) {
            let nx = pos.x + d.x;
            let ny = pos.y + d.y;

            if (
                nx >= 0 && nx < width &&
                ny >= 0 && ny < height &&
                !visited[ny][nx] &&
                grid[ny][nx] === 0 // только пустые клетки
            ) {
                visited[ny][nx] = true;
                queue.push({ pos: { x: nx, y: ny }, path: [...path, { x: nx, y: ny }] });
            }
        }

        // сортировка очереди по длине пути, чтобы развивать длинный путь
        queue.sort((a, b) => b.path.length - a.path.length);
    }

    return longestPath; // null, если пути нет
}

function update() {
    if(gameOver) return;

    const lengthThreshold = Math.floor(TOTAL_CELLS/8);

    if(!path || path.length===0){
        let chosenPath = null;

        if(snake.length <= lengthThreshold){
            let aStarPath = findPath();
            if(aStarPath && safePath(aStarPath)){
                chosenPath = aStarPath;
                survival=false;
            }
        } else {
            let rPath = reversedAStar();
            if(rPath && safePath(rPath)){
                chosenPath = rPath;
                survival=false;
            }
        }

        if(!chosenPath){
            // Survival mode
            survival=true;
            const tail = snake[snake.length-1];
            let freeNeighbors = neighbors(snake[0]);
            if(freeNeighbors.length>0) chosenPath = [freeNeighbors[0]];
            else chosenPath = [tail]; // forced
        }

        path = chosenPath;
    }

    // Move
    if(path.length>0){
        let next = path.shift();

        // Check collision
        if(snake.some(s=>s.x===next.x && s.y===next.y)){
            gameOver = true;
            return;
        }

        snake.unshift(next);

        if(next.x===apple.x && next.y===apple.y){
            apple = spawnApple();
            path=[];
        } else {
            snake.pop();
        }
    }
}

function gameLoop(){
    update();
    draw();
    setTimeout(gameLoop, 200);
}

gameLoop();
</script>
</body>
</html>
