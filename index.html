<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake AI</title>
<style>
  body {
    margin: 0;
    background-color: #151515;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }
  canvas {
    display: block;
    background-color: #151515;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const GRID_SIZE = 54;
const SNAKE_SIZE = 48;
const APPLE_SIZE = 51;
const ROWS = 10;
const COLS = 10;

canvas.width = COLS * GRID_SIZE;
canvas.height = ROWS * GRID_SIZE;

let snake = [{x: 4, y: 4}];
let apple = placeApple();
let dir = {x: 0, y: 0};
let path = [];
let survival = false;

function placeApple() {
    let empty = [];
    for (let y=0; y<ROWS; y++)
        for (let x=0; x<COLS; x++)
            if (!snake.some(s=>s.x===x && s.y===y)) empty.push({x,y});
    return empty[Math.floor(Math.random()*empty.length)];
}

function draw() {
    ctx.fillStyle = '#151515';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw apple
    ctx.fillStyle = '#ee0a17';
    ctx.fillRect(apple.x*GRID_SIZE + (GRID_SIZE-APPLE_SIZE)/2, apple.y*GRID_SIZE + (GRID_SIZE-APPLE_SIZE)/2, APPLE_SIZE, APPLE_SIZE);

    // draw snake
    for(let i=0;i<snake.length;i++){
        ctx.fillStyle = survival ? '#b20c18' : '#3ac322';
        ctx.fillRect(snake[i].x*GRID_SIZE + (GRID_SIZE-SNAKE_SIZE)/2,
                     snake[i].y*GRID_SIZE + (GRID_SIZE-SNAKE_SIZE)/2,
                     SNAKE_SIZE,SNAKE_SIZE);
    }
}

function neighbors(node) {
    return [
        {x: node.x+1, y: node.y},
        {x: node.x-1, y: node.y},
        {x: node.x, y: node.y+1},
        {x: node.x, y: node.y-1},
    ].filter(n=>n.x>=0 && n.x<COLS && n.y>=0 && n.y<ROWS && !snake.some(s=>s.x===n.x && s.y===n.y));
}

function bfs(start, goal) {
    let queue = [{node:start,path:[]}], visited = new Set([start.x+','+start.y]);
    while(queue.length){
        let {node,path} = queue.shift();
        if(node.x===goal.x && node.y===goal.y) return path.concat([node]);
        for(let n of neighbors(node)){
            let key = n.x+','+n.y;
            if(!visited.has(key)){
                visited.add(key);
                queue.push({node:n,path:path.concat([node])});
            }
        }
    }
    return null;
}

function reachableCells(head) {
    let visited = new Set([head.x+','+head.y]);
    let stack = [head];
    while(stack.length){
        let node = stack.pop();
        for(let n of neighbors(node)){
            let key = n.x+','+n.y;
            if(!visited.has(key)){
                visited.add(key);
                stack.push(n);
            }
        }
    }
    return visited.size;
}

function findPath() {
    let p = bfs(snake[0], apple);
    if(!p) return null;
    // check 80% rule
    let virtualSnake = snake.slice();
    let newHead = p[p.length-1];
    virtualSnake.unshift(newHead);
    if(virtualSnake.length>ROWS*COLS-1) virtualSnake.pop();
    let cells = reachableCells(newHead);
    if(cells/((ROWS*COLS)-virtualSnake.length)<0.8) return null;
    return p;
}

function update() {
    if(path.length===0){
        path = findPath();
        if(!path){
            survival = true;
            // survival: just move along available cells
            let nbs = neighbors(snake[0]);
            if(nbs.length>0) path = [nbs[0]];
        } else survival = false;
    }
    if(path.length>0){
        let next = path.shift();
        snake.unshift({x: next.x, y: next.y});
        if(next.x===apple.x && next.y===apple.y){
            apple = placeApple();
            path = [];
        } else snake.pop();
    }
    draw();
}

setInterval(update, 200);
</script>
</body>
</html>
