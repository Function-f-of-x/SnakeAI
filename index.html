<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake AI 1</title>
<style>
  body { margin:0; background:#000000; display:flex; justify-content:center; align-items:center; height:100vh; }
  canvas { background:#151515; display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const GRID_SIZE = 54;
const CELL_SIZE = 48;
const PADDING = GRID_SIZE - CELL_SIZE;

const COLS = 10;
const ROWS = 10;
const TOTAL_CELLS = COLS*ROWS;

canvas.width = COLS * GRID_SIZE;
canvas.height = ROWS * GRID_SIZE;

let snake = [{x:5, y:5}];
let apple = spawnApple();
let path = [];
let survival = false;
let gameOver = false;

function spawnApple(){
    let pos;
    do {
        pos = {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
    } while(snake.some(s => s.x===pos.x && s.y===pos.y));
    return pos;
}

function draw(){
    ctx.fillStyle = '#151515';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Apple
    ctx.fillStyle = '#ee0a17';
    ctx.fillRect(apple.x*GRID_SIZE + (GRID_SIZE-51)/2, apple.y*GRID_SIZE + (GRID_SIZE-51)/2, 51,51);

    // Snake
    ctx.fillStyle = gameOver ? '#808080' : (survival ? '#b20c18' : '#3ac322');
    snake.forEach(s=>{
        ctx.fillRect(s.x*GRID_SIZE + (GRID_SIZE-CELL_SIZE)/2, s.y*GRID_SIZE + (GRID_SIZE-CELL_SIZE)/2, CELL_SIZE, CELL_SIZE);
    });
}

function neighbors(node, futureSnake=[]){
    const deltas = [
        {x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}
    ];
    return deltas.map(d=>({x: node.x+d.x, y: node.y+d.y}))
                 .filter(n=>n.x>=0 && n.x<COLS && n.y>=0 && n.y<ROWS)
                 .filter(n=>!futureSnake.some(s=>s.x===n.x && s.y===n.y));
}

function heuristic(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }

function aStar(start, goal, futureSnake=[]){
    let open = [{node:start, g:0, f:heuristic(start,goal), parent:null}];
    let closed = [];

    while(open.length>0){
        open.sort((a,b)=>a.f-b.f);
        const current = open.shift();
        if(current.node.x===goal.x && current.node.y===goal.y){
            let p=[];
            let c=current;
            while(c){ p.unshift(c.node); c=c.parent; }
            return p.slice(1);
        }
        closed.push(current.node);
        for(const n of neighbors(current.node, futureSnake)){
            if(closed.some(c=>c.x===n.x && c.y===n.y)) continue;
            let g=current.g+1;
            let f=g+heuristic(n,goal);
            if(open.some(o=>o.node.x===n.x && o.node.y===n.y && o.f<=f)) continue;
            open.push({node:n,g,f,parent:current});
        }
    }
    return null;
}

// BFS для проверки доступности 80%
function bfs(startPos, occupied){
    let queue=[startPos], visited=[`${startPos.x},${startPos.y}`], count=1;
    while(queue.length>0){
        let cur=queue.shift();
        for(let n of neighbors(cur, occupied)){
            if(!visited.includes(`${n.x},${n.y}`)){
                queue.push(n);
                visited.push(`${n.x},${n.y}`);
                count++;
            }
        }
    }
    return count;
}

function safePath(pathToCheck){
    if(!pathToCheck) return false;
    const futureSnake = [...snake];
    pathToCheck.forEach(p=>futureSnake.unshift(p));
    const reachable = bfs(futureSnake[0], futureSnake);
    const emptyCells = COLS*ROWS - futureSnake.length;
    return reachable >= Math.floor(0.8*emptyCells);
}

function reversedAStar() {
    const head = snake[0];
    const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
    let longestPath = [];
    
    function dfs(pos, path) {
        visited[pos.y][pos.x] = true;
        path.push(pos);

        // Если дошли до яблока — проверяем, длиннее ли путь
        if(pos.x === apple.x && pos.y === apple.y){
            if(path.length > longestPath.length) longestPath = [...path];
        } else {
            // Сортируем соседей так, чтобы двигаться в стороны максимально вдали от яблока
            const dirs = neighbors(pos).sort((a,b)=>{
                return heuristic(b, apple) - heuristic(a, apple);
            });
            for(let n of dirs){
                if(!visited[n.y][n.x]){
                    // Кратковременный path для проверки 80%
                    const futureSnake = [...path.map(p=>({x:p.x,y:p.y})), ...snake.slice(0, snake.length - path.length)];
                    if(bfs(n, futureSnake) >= Math.floor(0.8*(COLS*ROWS - futureSnake.length))){
                        dfs(n, path);
                    }
                }
            }
        }

        path.pop();
        visited[pos.y][pos.x] = false;
    }

    dfs(head, []);
    return longestPath.length > 0 ? longestPath.slice(1) : null;
}


function update(){
    if(gameOver) return;

    const lengthThreshold = Math.floor(TOTAL_CELLS/8);

    if(!path || path.length===0){
        let chosenPath = null;

        // выбираем метод
        if(snake.length <= lengthThreshold){
            let aPath = aStar(snake[0], apple, snake);
            if(aPath && safePath(aPath)){ chosenPath=aPath; survival=false; }
        } else {
            let rPath = reversedAStar();
            if(rPath && safePath(rPath)){ chosenPath=rPath; survival=false; }
        }

        // Survival mode
        if(!chosenPath){
            survival=true;
            const tail = snake[snake.length-1];
            let freeNeighbors = neighbors(snake[0]);
            if(freeNeighbors.length>0) chosenPath=[freeNeighbors[0]];
            else chosenPath=[tail];
        }

        path=chosenPath;
    }

    // Move
    if(path.length>0){
        let next = path.shift();

        if(snake.some(s=>s.x===next.x && s.y===next.y)){
            gameOver=true;
            return;
        }

        snake.unshift(next);

        if(next.x===apple.x && next.y===apple.y){
            apple = spawnApple();
            path=[];
        } else {
            snake.pop();
        }
    }
}

function gameLoop(){
    update();
    draw();
    setTimeout(gameLoop, 200);
}

gameLoop();
</script>
</body>
</html>
