<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>AI Snake</title>
  <style>
    canvas { background: #000; display: block; margin: auto; }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="400" height="400"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const tileSize = 20;
const tilesX = canvas.width / tileSize;
const tilesY = canvas.height / tileSize;

let snake = [{x: 5, y: 5}];
let apple = randomApple();
let path = [];
let gameOver = false;
let survival = false;
let reversedMode = false;

function randomApple() {
  let a;
  do {
    a = {x: Math.floor(Math.random()*tilesX), y: Math.floor(Math.random()*tilesY)};
  } while (snake.some(s => s.x === a.x && s.y === a.y));
  return a;
}

// Flood-fill: количество доступных клеток из точки
function floodFillCount(start) {
  let visited = new Set();
  let queue = [start];
  let count = 0;
  while(queue.length){
    let {x,y} = queue.shift();
    let key = x+","+y;
    if(x<0||y<0||x>=tilesX||y>=tilesY) continue;
    if(snake.some(s=>s.x===x&&s.y===y) && !(x===snake[snake.length-1].x && y===snake[snake.length-1].y)) continue;
    if(visited.has(key)) continue;
    visited.add(key);
    count++;
    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
      queue.push({x:x+dx,y:y+dy});
    });
  }
  return count;
}

// A* поиск
function aStar(start, goal) {
  let open = [start];
  let cameFrom = {};
  let gScore = {};
  gScore[start.x+","+start.y] = 0;

  function heuristic(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y);}
  while(open.length){
    open.sort((a,b)=>(gScore[a.x+","+a.y]+heuristic(a,goal))-(gScore[b.x+","+b.y]+heuristic(b,goal)));
    let current = open.shift();
    if(current.x===goal.x && current.y===goal.y){
      let path = [];
      while(current){
        path.push(current);
        current = cameFrom[current.x+","+current.y];
      }
      return path.reverse();
    }
    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
      let nx=current.x+dx, ny=current.y+dy;
      if(nx<0||ny<0||nx>=tilesX||ny>=tilesY) return;
      if(snake.some(s=>s.x===nx&&s.y===ny) && !(nx===goal.x&&ny===goal.y) && !(nx===snake[snake.length-1].x && ny===snake[snake.length-1].y)) return;
      let neighbor={x:nx,y:ny};
      let tentative = gScore[current.x+","+current.y]+1;
      if(tentative < (gScore[neighbor.x+","+neighbor.y]||Infinity)){
        cameFrom[neighbor.x+","+neighbor.y]=current;
        gScore[neighbor.x+","+neighbor.y]=tentative;
        if(!open.some(o=>o.x===nx&&o.y===ny)) open.push(neighbor);
      }
    });
  }
  return null;
}

// Жадный длинный путь (инвертированный поиск)
function greedyLongest(start, goal) {
  let path = [start];
  let current = {...start};
  while(!(current.x===goal.x && current.y===goal.y)){
    let moves = [[1,0],[-1,0],[0,1],[0,-1]];
    moves.sort(()=>Math.random()-0.5);
    let next = null;
    let maxSpace = -1;
    for(let [dx,dy] of moves){
      let nx=current.x+dx, ny=current.y+dy;
      if(nx<0||ny<0||nx>=tilesX||ny>=tilesY) continue;
      if(snake.some(s=>s.x===nx&&s.y===ny) && !(nx===goal.x&&ny===goal.y)) continue;
      let space=floodFillCount({x:nx,y:ny});
      if(space>maxSpace){maxSpace=space; next={x:nx,y:ny};}
    }
    if(!next) break;
    current=next;
    path.push(current);
    if(path.length>tilesX*tilesY) break;
  }
  return path.length>1?path:null;
}

// обновление логики
function update() {
  if(gameOver) return;

  if(!path.length){
    reversedMode = snake.length > (tilesX*tilesY)/8;
    let newPath = null;
    if(reversedMode){
      newPath = greedyLongest(snake[0], apple);
    } else {
      newPath = aStar(snake[0], apple);
    }
    if(newPath){
      let reachable = floodFillCount(newPath[newPath.length-1]);
      if(reachable >= 0.8*(tilesX*tilesY - snake.length)){
        survival = false;
        path = newPath.slice(1);
      } else {
        survival = true;
      }
    } else {
      survival = true;
    }
  }

  let next;
  if(survival){
    // выбираем безопасный ход
    let moves = [[1,0],[-1,0],[0,1],[0,-1]];
    let best=null, maxSpace=-1;
    for(let [dx,dy] of moves){
      let nx=snake[0].x+dx, ny=snake[0].y+dy;
      if(nx<0||ny<0||nx>=tilesX||ny>=tilesY) continue;
      if(snake.some(s=>s.x===nx&&s.y===ny)) continue;
      let space=floodFillCount({x:nx,y:ny});
      if(space>maxSpace){maxSpace=space; best={x:nx,y:ny};}
    }
    next=best;
    // проверяем, появился ли путь
    let retry=aStar(snake[0],apple);
    if(retry){
      let reachable=floodFillCount(retry[retry.length-1]);
      if(reachable >= 0.8*(tilesX*tilesY - snake.length)){
        survival=false;
        path=retry.slice(1);
      }
    }
  } else {
    next=path.shift();
  }

  if(!next){gameOver=true; return;}

  if(snake.some(s=>s.x===next.x&&s.y===next.y)){
    gameOver=true; return;
  }

  snake.unshift(next);
  if(next.x===apple.x && next.y===apple.y){
    apple=randomApple();
    path=[];
  } else {
    snake.pop();
  }
}

// отрисовка
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // яблоко
  ctx.fillStyle="#ee0a17";
  ctx.fillRect(apple.x*tileSize, apple.y*tileSize, tileSize, tileSize);

  // змейка
  ctx.fillStyle=gameOver?"#555555":"#00ff00";
  snake.forEach((s,i)=>{
    ctx.fillRect(s.x*tileSize, s.y*tileSize, tileSize, tileSize);
  });
}

function loop(){
  update();
  draw();
  if(!gameOver) setTimeout(loop,100);
}
loop();
</script>
</body>
</html>
