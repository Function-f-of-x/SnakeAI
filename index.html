<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake AI Safe Paths</title>
<script src="https://cdn.jsdelivr.net/npm/p5@1.3.1/lib/p5.js"></script>
<style>
  body { margin:0; background:#000000; display:flex; justify-content:center; align-items:center; height:100vh; }
  canvas { display:block; }
</style>
</head>
<body>
<script>
// ======= Apple class =======
class Apple {
    constructor() {
        this.boxes = [];
        for (let i = 0; i < 40; i++) {
            for (let j = 0; j < 20; j++) {
                this.boxes.push(createVector(i, j));
            }
        }
        this.generate([createVector(0,0), createVector(1,0), createVector(2,0)]);
    }
    generate(snake_body) {
        const empty_boxes = this.boxes.filter(v=>{
            for (let s of snake_body) if (v.x===s.x && v.y===s.y) return false;
            return true;
        });
        if (empty_boxes.length===0) return false;
        let pos = empty_boxes[int(random(0, empty_boxes.length))];
        this.x = pos.x; this.y = pos.y;
        return true;
    }
    show() {
        fill('#ee0a17'); noStroke();
        rect(this.x*30, this.y*30, 30, 30);
    }
}

// ======= Snake class =======
class Snake {
    constructor() {
        this.body = [];
        for (let i=0;i<3;i++) this.body[i]=createVector(i,0);
        this.x_dir=1; this.y_dir=0;
        this.path = [];
    }
    getHead() { return this.body[this.body.length-1]; }
    getTail() { return this.body[0]; }
    changeDirection(x,y){ if (!(abs(this.x_dir-x)==2||abs(this.y_dir-y)==2)){this.x_dir=x;this.y_dir=y;} }
    up(){this.changeDirection(0,-1);}
    down(){this.changeDirection(0,1);}
    left(){this.changeDirection(-1,0);}
    right(){this.changeDirection(1,0);}
    show(){
        fill('#3ac322'); noStroke();
        for (let s of this.body) rect(s.x*30, s.y*30,30,30);
    }
}

// ======= Node class =======
class Node{
    constructor(x,y){this.x=x;this.y=y;this.parent=null;this.f=0;this.g=0;this.h=0;}
    equals(other){return this.x===other.x && this.y===other.y;}
}

// ======= Search class =======
class Search {
    constructor(snake, apple){this.snake=snake;this.apple=apple;}
    
    refreshMaze(){
        let maze=[]; for(let j=0;j<20;j++){ let row=[]; for(let i=0;i<40;i++) row.push(0); maze.push(row);}
        for(let s of this.snake.body) maze[s.y][s.x]=-1;
        let head=this.snake.getHead(), tail=this.snake.getTail();
        maze[head.y][head.x]=1; maze[tail.y][tail.x]=2;
        return maze;
    }

    getPath(){
        let maze=this.refreshMaze();
        let start,end;
        for(let j=0;j<20;j++) for(let i=0;i<40;i++){
            if(maze[j][i]==1) start={x:i,y:j};
            else if(maze[j][i]==2) end={x:i,y:j};
        }
        const threshold=Math.floor(40*20/8);
        if(this.snake.body.length <= threshold){
            this.snake.path=this.AStar(maze,start,this.apple);
        } else {
            this.snake.path=this.reversedAStar(maze,start,end);
        }
    }

    neighbors(node,maze){
        const deltas=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
        return deltas.map(d=>({x:node.x+d.x,y:node.y+d.y}))
                     .filter(n=>n.x>=0&&n.x<40&&n.y>=0&&n.y<20)
                     .filter(n=>maze[n.y][n.x]!=-1);
    }

    reachableCells(start, occupied){
        const queue=[start]; const visited=new Set([`${start.x},${start.y}`]); let count=1;
        while(queue.length>0){
            let cur=queue.shift();
            const deltas=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
            for(let d of deltas){
                let nx=cur.x+d.x, ny=cur.y+d.y;
                if(nx<0||nx>=40||ny<0||ny>=20) continue;
                if(occupied.some(s=>s.x===nx&&s.y===ny)) continue;
                const key=`${nx},${ny}`; if(!visited.has(key)){visited.add(key);queue.push({x:nx,y:ny});count++;}
            }
        }
        return count;
    }

    heuristic(a,b){return abs(a.x-b.x)+abs(a.y-b.y);}

    AStar(maze, start, goal) {
    let start_node = new Node(start.x, start.y);
    let end_node = new Node(goal.x, goal.y);
    let open_list = [];
    let closed_list = [];
    open_list.push(start_node);
    let possible_paths = [];
    const adjacent_squares = [
        [0, -1],
        [0, 1],
        [-1, 0],
        [1, 0],
    ];

    while (open_list.length > 0) {
        // Найти узел с наименьшей стоимостью f
        let current_node = open_list[0];
        let current_index = 0;
        for (let i = 1; i < open_list.length; i++) {
            if (open_list[i].f < current_node.f) {
                current_node = open_list[i];
                current_index = i;
            }
        }

        open_list.splice(current_index, 1);
        closed_list.push(current_node);

        // Если достигли цели
        if (current_node.equals(end_node)) {
            let path = [];
            let current = current_node;
            while (current != null) {
                path.push({x: current.x, y: current.y}); // возвращаем plain объекты, как раньше
                current = current.parent;
            }
            path.reverse();
            // Проверка безопасности: имитируем змею после этого пути
            const futureSnake = [...this.snake.body, ...path.slice(1)];
            const emptyCells = 40 * 20 - futureSnake.length;
            if (this.reachableCells(futureSnake[0], futureSnake) >= Math.floor(0.8 * emptyCells)) {
                possible_paths.push(path);
            }
            // Не выходим сразу — продолжаем искать другие пути (на случай, если найдётся короче)
        }

        // Генерация соседей
        let children = [];
        for (let i = 0; i < adjacent_squares.length; i++) {
            let nx = current_node.x + adjacent_squares[i][0];
            let ny = current_node.y + adjacent_squares[i][1];
            if (nx >= 0 && nx < 40 && ny >= 0 && ny < 20) {
                if (maze[ny][nx] !== -1) { // не стена (тело змеи)
                    let new_node = new Node(nx, ny);
                    children.push(new_node);
                }
            }
        }

        for (let child of children) {
            // Пропустить, если в closed_list
            let inClosed = closed_list.some(node => node.equals(child));
            if (inClosed) continue;

            // Расчёт g, h, f
            child.g = current_node.g + 1;
            child.h = this.heuristic(child, end_node);
            child.f = child.g + child.h;
            child.parent = current_node;

            // Проверка: безопасен ли этот шаг?
            const futureSnake = [...this.snake.body, {x: child.x, y: child.y}];
            const emptyCells = 40 * 20 - futureSnake.length;
            if (this.reachableCells({x: child.x, y: child.y}, futureSnake) < Math.floor(0.8 * emptyCells)) {
                continue; // пропустить небезопасный узел
            }

            // Проверка в open_list
            let inOpen = false;
            for (let i = 0; i < open_list.length; i++) {
                if (open_list[i].equals(child)) {
                    if (child.g < open_list[i].g) {
                        open_list[i] = child; // обновить, если лучше
                    }
                    inOpen = true;
                    break;
                }
            }

            if (!inOpen) {
                open_list.push(child);
            }
        }
    }

    // Найти самый короткий безопасный путь
    if (possible_paths.length === 0) return [];

    let shortest = possible_paths[0];
    for (let i = 1; i < possible_paths.length; i++) {
        if (possible_paths[i].length < shortest.length) {
            shortest = possible_paths[i];
        }
    }

    return shortest.slice(1); // убираем стартовую позицию (голову), как раньше
}


    reversedAStar(maze, start, end) {
        let start_node = new Node(start.x, start.y);
        let end_node = new Node(end.x, end.y);
        let open_list = [];
        let closed_list = [];
        open_list.push(start_node);
        let possible_paths = [];
        const adjacent_squares = [
            [0, -1],
            [0, 1],
            [-1, 0],
            [1, 0],
        ];

        while (open_list.length > 0) {

            let current_node = open_list[0];
            let current_index = 0;
            let index = 0;

            for (let i = 0; i < open_list.length; i++) {
                if (open_list[i].f < current_node.f) {
                    current_node = open_list[i];
                    current_index = index;
                }
                index++;
            }

            open_list.splice(current_index, 1);
            closed_list.push(current_node);
            if (current_node.equals(end_node)) {
                let path = [];
                let current = current_node;
                while (current != null) {
                    path.push(current);
                    current = current.parent;
                }
                possible_paths.push(path.reverse());
            }

            let children = [];
            for (let i = 0; i < adjacent_squares.length; i++) {
                let node_position = [current_node.x + adjacent_squares[i][0], current_node.y + adjacent_squares[i][1]];
                if (node_position[0] <= 39 && node_position[0] >= 0) {
                    if (node_position[1] <= 19 && node_position[1] >= 0) {
                        if (maze[node_position[1]][node_position[0]] != -1) {
                            let new_node = new Node(node_position[0], node_position[1]);
                            children.push(new_node);
                        }
                    }
                }
            }

            for (let i = 0; i < children.length; i++) {
                let if_in_closed_list = false;
                for (let j = 0; j < closed_list.length; j++) {
                    if (children[i].equals(closed_list[j])) {
                        if_in_closed_list = true;
                    }
                }
                if (!if_in_closed_list) {
                    children[i].g = current_node.g + 2;
                    children[i].h = abs(children[i].x - end_node.x) + abs(children[i].y - end_node.y);
                    children[i].f = children[i].g + children[i].h;
                    let present = false;
                    for (let j = 0; j < open_list.length; j++) {
                        if (children[i].equals(open_list[j]) && children[i].g < open_list[j].g) {
                            present = true;
                        } else if (children[i].equals(open_list[j]) && children[i].g >= open_list[j].g) {
                            open_list[j] = children[i];
                            open_list[j].parent = current_node;
                        }
                    }
                    if (!present) {
                        children[i].parent = current_node;
                        open_list.push(children[i]);
                    }
                }
            }
        }
        
        let path = possible_paths.length > 0 ? possible_paths[0] : [];
            for (let i = 1; i < possible_paths.length; i++) {
                if (possible_paths[i].length < path.length) {
                    path = possible_paths[i];
                }
            }
        return path;
    }
}

// ======= p5.js setup =======
let snake, apple, search;
function setup(){
    createCanvas(1200,600);
    snake=new Snake();
    apple=new Apple();
    search=new Search(snake,apple);
    search.getPath();
    frameRate(200);
}

function draw(){
    background('#151515');
    apple.show();
    snake.show();
    updateSnake();
}

function updateSnake(){
    if(snake.path.length>0){
        let next=snake.path.shift();
        snake.body.push(createVector(next.x,next.y));
        if(next.x===apple.x && next.y===apple.y){
            apple.generate(snake.body);
            search.getPath();
        } else {
            snake.body.shift();
        }
    } else {
        search.getPath();
    }
}
</script>
</body>
</html>
