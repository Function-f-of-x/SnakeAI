<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake AI</title>
<style>
  body { margin:0; background:#000000; display:flex; justify-content:center; align-items:center; height:100vh; }
  canvas { background:#151515; display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const GRID_SIZE = 54;
const CELL_SIZE = 48;
const PADDING = GRID_SIZE - CELL_SIZE;

const COLS = 10;
const ROWS = 10;

canvas.width = COLS * GRID_SIZE;
canvas.height = ROWS * GRID_SIZE;

let snake = [{x:5, y:5}];
let apple = spawnApple();
let path = [];
let survival = false;

function spawnApple() {
    let pos;
    do {
        pos = {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
    } while(snake.some(s => s.x===pos.x && s.y===pos.y));
    return pos;
}

function draw() {
    ctx.fillStyle = '#151515';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Draw apple
    ctx.fillStyle = '#ee0a17';
    ctx.fillRect(apple.x*GRID_SIZE + (GRID_SIZE-51)/2, apple.y*GRID_SIZE + (GRID_SIZE-51)/2, 51,51);

    // Draw snake
    ctx.fillStyle = survival ? '#b20c18' : '#3ac322';
    snake.forEach((s,i) => {
        ctx.fillRect(s.x*GRID_SIZE + (GRID_SIZE-CELL_SIZE)/2, s.y*GRID_SIZE + (GRID_SIZE-CELL_SIZE)/2, CELL_SIZE, CELL_SIZE);
    });
}

function neighbors(node){
    const deltas = [
        {x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}
    ];
    return deltas.map(d=>({x: node.x+d.x, y: node.y+d.y}))
                 .filter(n=>n.x>=0 && n.x<COLS && n.y>=0 && n.y<ROWS)
                 .filter(n=>!snake.some(s=>s.x===n.x && s.y===n.y));
}

// Simple A* heuristic
function heuristic(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }

function findPath() {
    const start = snake[0];
    const goal = apple;
    let open = [{node:start, g:0, f:heuristic(start,goal), parent:null}];
    let closed = [];

    while(open.length>0){
        open.sort((a,b)=>a.f-b.f);
        const current = open.shift();
        if(current.node.x===goal.x && current.node.y===goal.y){
            // reconstruct path
            let p = [];
            let c = current;
            while(c){
                p.unshift(c.node);
                c = c.parent;
            }
            return p.slice(1); // exclude head
        }
        closed.push(current.node);
        for(const n of neighbors(current.node)){
            if(closed.some(c=>c.x===n.x && c.y===n.y)) continue;
            let g = current.g+1;
            let f = g + heuristic(n,goal);
            if(open.some(o=>o.node.x===n.x && o.node.y===n.y && o.f<=f)) continue;
            open.push({node:n,g,f,parent:current});
        }
    }
    return null; // no path
}

// Survival check: head must reach >=80% empty cells
function safePath(pathToCheck){
    if(!pathToCheck) return false;
    const futureSnake = [...snake];
    pathToCheck.forEach(p=>futureSnake.unshift(p));
    let reachable = bfs(futureSnake[0], futureSnake);
    const emptyCells = COLS*ROWS - futureSnake.length;
    return reachable >= Math.floor(0.8*emptyCells);
}

// BFS to count reachable cells
function bfs(startPos, occupied){
    let queue=[startPos], visited=[`${startPos.x},${startPos.y}`], count=1;
    while(queue.length>0){
        let cur = queue.shift();
        for(let n of neighbors(cur)){
            if(!visited.includes(`${n.x},${n.y}`) && !occupied.some(s=>s.x===n.x && s.y===n.y)){
                queue.push(n);
                visited.push(`${n.x},${n.y}`);
                count++;
            }
        }
    }
    return count;
}

// Reverse A* (longest path)
function reversedAStar() {
    let start = snake[0], goal = apple;
    let allPaths = [];
    function dfs(path, visited){
        let cur = path[path.length-1];
        if(cur.x===goal.x && cur.y===goal.y){
            allPaths.push([...path]);
            return;
        }
        for(let n of neighbors(cur)){
            if(!visited.some(v=>v.x===n.x && v.y===n.y)){
                visited.push(n);
                path.push(n);
                dfs(path, visited);
                path.pop();
                visited.pop();
            }
        }
    }
    dfs([start],[...snake]);
    if(allPaths.length===0) return null;
    // longest path
    allPaths.sort((a,b)=>b.length - a.length);
    return allPaths[0].slice(1);
}

function update() {
    // Choose path algorithm
    if(!path || path.length===0){
        let aStarPath = findPath();
        if(aStarPath && safePath(aStarPath)){
            path = aStarPath;
            survival=false;
        } else {
            path = reversedAStar();
            if(!path){
                // survival mode
                survival=true;
                // move towards tail (last element)
                path = [snake[snake.length-1]];
            }
        }
    }

    // Move
    if(path.length>0){
        let next = path.shift();
        snake.unshift(next);

        // Eat apple
        if(next.x===apple.x && next.y===apple.y){
            apple = spawnApple();
            path = []; // recalc path next tick
        } else {
            snake.pop();
        }
    }
}

function gameLoop(){
    update();
    draw();
    setTimeout(gameLoop, 200);
}

gameLoop();
</script>
</body>
</html>
