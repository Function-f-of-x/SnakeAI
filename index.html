<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake AI Safe Paths</title>
<style>
  body { margin:0; background:#000; display:flex; justify-content:center; align-items:center; height:100vh; }
  canvas { background:#151515; display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const COLS = 10, ROWS = 10;
const GRID_SIZE = 54, CELL_SIZE = 48;
const TOTAL_CELLS = COLS*ROWS;

canvas.width = COLS * GRID_SIZE;
canvas.height = ROWS * GRID_SIZE;

let snake = [{x:5,y:5}];
let apple = spawnApple();
let path = [];
let survival=false;
let gameOver=false;

// ----------------- генерация яблока -----------------
function spawnApple(){
    let pos;
    do {
        pos = {x:Math.floor(Math.random()*COLS), y:Math.floor(Math.random()*ROWS)};
    } while(snake.some(s=>s.x===pos.x && s.y===pos.y));
    return pos;
}

// ----------------- визуализация -----------------
function draw(){
    ctx.fillStyle='#151515';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // яблоко
    ctx.fillStyle='#ee0a17';
    ctx.fillRect(apple.x*GRID_SIZE+(GRID_SIZE-51)/2, apple.y*GRID_SIZE+(GRID_SIZE-51)/2,51,51);

    // змейка
    ctx.fillStyle = gameOver?'#808080':(survival?'#b20c18':'#3ac322');
    snake.forEach(s=>{
        ctx.fillRect(s.x*GRID_SIZE+(GRID_SIZE-CELL_SIZE)/2,s.y*GRID_SIZE+(GRID_SIZE-CELL_SIZE)/2,CELL_SIZE,CELL_SIZE);
    });
}

// ----------------- вспомогательные функции -----------------
function neighbors(node){
    const deltas=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
    return deltas.map(d=>({x:node.x+d.x,y:node.y+d.y}))
                 .filter(n=>n.x>=0&&n.x<COLS&&n.y>=0&&n.y<ROWS)
                 .filter(n=>!snake.some(s=>s.x===n.x&&s.y===n.y));
}

function heuristic(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y);}

// BFS для подсчета доступных клеток
function reachableCells(start,occupied){
    let queue=[start];
    let visited=new Set([`${start.x},${start.y}`]);
    let count=1;
    while(queue.length>0){
        const cur=queue.shift();
        const deltas=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
        for(const d of deltas){
            const nx=cur.x+d.x, ny=cur.y+d.y;
            if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
            if(occupied.some(s=>s.x===nx&&s.y===ny)) continue;
            const key=`${nx},${ny}`;
            if(!visited.has(key)){
                visited.add(key);
                queue.push({x:nx,y:ny});
                count++;
            }
        }
    }
    return count;
}

// ----------------- обычный A* -----------------
function findPath(){
    const start=snake[0], goal=apple;
    let open=[{node:start,g:0,f:heuristic(start,goal),parent:null}];
    let closed=[];

    while(open.length>0){
        open.sort((a,b)=>a.f-b.f);
        const current=open.shift();
        if(current.node.x===goal.x && current.node.y===goal.y){
            let p=[]; let c=current;
            while(c){p.unshift(c.node); c=c.parent;}
            return p.slice(1);
        }
        closed.push(current.node);

        for(const n of neighbors(current.node)){
            if(closed.some(c=>c.x===n.x&&c.y===n.y)) continue;
            const future=[n,...snake];
            const emptyCells=COLS*ROWS-future.length;
            if(reachableCells(future[0],future)<Math.floor(0.8*emptyCells)) continue;

            const g=current.g+1;
            const f=g+heuristic(n,goal);
            if(open.some(o=>o.node.x===n.x&&o.node.y===n.y&&o.f<=f)) continue;
            open.push({node:n,g,f,parent:current});
        }
    }
    return null;
}

// ----------------- Reversed A* -----------------
function reversedAStar(){
    const start=snake[0], goal=apple;
    let open=[{node:start,g:0,f:-heuristic(start,goal),parent:null,path:[]}];
    let closed=[];

    while(open.length>0){
        open.sort((a,b)=>b.f-a.f);
        const current=open.shift();

        if(current.node.x===goal.x && current.node.y===goal.y){
            let p=[...current.path,current.node];
            const future=[...snake,...p.slice(1)];
            if(reachableCells(future[0],future)>=Math.floor(0.8*(COLS*ROWS-future.length)))
                return p.slice(1);
            else continue;
        }

        closed.push(current.node);

        for(const n of neighbors(current.node)){
            if(closed.some(c=>c.x===n.x&&c.y===n.y)) continue;
            const future=[...snake,...current.path,n];
            if(reachableCells(n,future)<Math.floor(0.8*(COLS*ROWS-future.length))) continue;

            let g=current.g+1;
            let f=g-heuristic(n,goal);
            if(open.some(o=>o.node.x===n.x&&o.node.y===n.y&&o.f>=f)) continue;
            open.push({node:n,g,f,parent:current,path:[...current.path,n]});
        }
    }
    return null;
}

// ----------------- движение змейки -----------------
function update(){
    if(gameOver) return;
    const threshold=Math.floor(TOTAL_CELLS/8);

    if(!path||path.length===0){
        let chosen=null;
        if(snake.length<=threshold) chosen=findPath(),survival=false;
        else chosen=reversedAStar(),survival=false;

        if(!chosen){
            survival=true;
            const free=neighbors(snake[0]);
            chosen=free.length>0?[free[0]]:[snake[snake.length-1]];
        }
        path=chosen;
    }

    if(path.length>0){
        const next=path.shift();
        if(snake.some(s=>s.x===next.x&&s.y===next.y)){gameOver=true; return;}
        snake.unshift(next);
        if(next.x===apple.x && next.y===apple.y){apple=spawnApple(); path=[];}
        else snake.pop();
    }
}

// ----------------- игровой цикл -----------------
function gameLoop(){
    update();
    draw();
    setTimeout(gameLoop,200);
}

gameLoop();
</script>
</body>
</html>
