<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake AI</title>
<style>
  body {
    margin: 0;
    background-color: #151515;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }
  canvas {
    border: 1px solid #333;
  }
</style>
</head>
<body>
<canvas id="snakeCanvas" width="1080" height="1080"></canvas>
<script>
const canvas = document.getElementById('snakeCanvas');
const ctx = canvas.getContext('2d');

const GRID_SIZE = 54;
const CELL_INNER = 48;
const CELL_GAP = GRID_SIZE - CELL_INNER;
const WIDTH = canvas.width / GRID_SIZE | 0;
const HEIGHT = canvas.height / GRID_SIZE | 0;

// Цвета
const SNAKE_COLOR = '#3ac322';
const SNAKE_SURVIVAL_COLOR = '#b20c18';
const APPLE_COLOR = '#e9102';
const BG_COLOR = '#151515';

// Игра
let snake = [{x: Math.floor(WIDTH/2), y: Math.floor(HEIGHT/2)}];
let dir = {x:0,y:0};
let apple = {x:0,y:0};
let mode = 'A*'; // A*, Reversed, Hamiltonian
let survival = false;

// Создаём яблоко
function placeApple() {
    do {
        apple.x = Math.floor(Math.random()*WIDTH);
        apple.y = Math.floor(Math.random()*HEIGHT);
    } while (snake.some(s=>s.x===apple.x && s.y===apple.y));
}

// Рисуем сетку
function draw() {
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Яблоко
    ctx.fillStyle = APPLE_COLOR;
    ctx.fillRect(
        apple.x*GRID_SIZE + (GRID_SIZE-51)/2,
        apple.y*GRID_SIZE + (GRID_SIZE-51)/2,
        51,51
    );

    // Змейка
    for(let i=0;i<snake.length;i++){
        ctx.fillStyle = survival ? SNAKE_SURVIVAL_COLOR : SNAKE_COLOR;
        ctx.fillRect(
            snake[i].x*GRID_SIZE + CELL_GAP/2,
            snake[i].y*GRID_SIZE + CELL_GAP/2,
            CELL_INNER,CELL_INNER
        );
    }
}

// Проверка границ и столкновений
function isCollision(x,y){
    return x<0||y<0||x>=WIDTH||y>=HEIGHT || snake.some(s=>s.x===x && s.y===y);
}

// Проверка достижимости 80% пустых клеток
function reachable80Percent(headX,headY,body){
    const visited = Array.from({length:WIDTH},()=>Array(HEIGHT).fill(false));
    const queue = [{x:headX,y:headY}];
    let count=0;
    while(queue.length){
        const {x,y} = queue.shift();
        if(visited[x][y]) continue;
        visited[x][y]=true;
        count++;
        const moves = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
        for(const m of moves){
            const nx=x+m.x, ny=y+m.y;
            if(nx>=0 && ny>=0 && nx<WIDTH && ny<HEIGHT && !body.some(s=>s.x===nx && s.y===ny) && !visited[nx][ny]){
                queue.push({x:nx,y:ny});
            }
        }
    }
    const emptyCells = WIDTH*HEIGHT - snake.length;
    return count >= 0.8*emptyCells;
}

// Простейший A* поиск
function aStar(start,end,body){
    // очень базовый A* без оптимизаций
    const open = [{pos:start, path:[]}];
    const visited = new Set();
    const key = ({x,y})=>`${x},${y}`;
    while(open.length){
        open.sort((a,b)=>{
            const f1=a.path.length + Math.abs(a.pos.x-end.x)+Math.abs(a.pos.y-end.y);
            const f2=b.path.length + Math.abs(b.pos.x-end.x)+Math.abs(b.pos.y-end.y);
            return f1-f2;
        });
        const current = open.shift();
        if(current.pos.x===end.x && current.pos.y===end.y) return current.path[0];
        visited.add(key(current.pos));
        const moves = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
        for(const m of moves){
            const nx=current.pos.x+m.x, ny=current.pos.y+m.y;
            if(nx>=0 && ny>=0 && nx<WIDTH && ny<HEIGHT && !body.some(s=>s.x===nx && s.y===ny) && !visited.has(`${nx},${ny}`)){
                open.push({pos:{x:nx,y:ny}, path: current.path.concat([{x:nx,y:ny}])});
            }
        }
    }
    return null;
}

// Реверс A* (поиск максимального пути)
function reversedAStar(start,end,body){
    // Простейший: выбираем путь, который увеличивает манхэттенскую дистанцию
    const moves = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
    let best=null;
    let maxDist=-1;
    for(const m of moves){
        const nx=start.x+m.x, ny=start.y+m.y;
        if(nx>=0 && ny>=0 && nx<WIDTH && ny<HEIGHT && !body.some(s=>s.x===nx && s.y===ny)){
            const dist = Math.abs(nx-end.x)+Math.abs(ny-end.y);
            if(dist>maxDist){
                maxDist=dist;
                best={x:nx,y:ny};
            }
        }
    }
    return best;
}

// Hamiltonian cycle (без сокращений)
function hamiltonianMove(snake){
    // Очень простой зигзаг через весь grid
    const head = snake[0];
    if(head.y%2===0){
        if(head.x<WIDTH-1) return {x:head.x+1,y:head.y};
        else return {x:head.x,y:head.y+1};
    } else {
        if(head.x>0) return {x:head.x-1,y:head.y};
        else return {x:head.x,y:head.y+1};
    }
}

// Основная логика AI
function nextMove(){
    const head = snake[0];
    const body = snake.slice(1);
    survival=false;

    // Проверка: путь к яблоку безопасен?
    const safePath = reachable80Percent(apple.x,apple.y,body);
    if(safePath){
        if(snake.length<WIDTH/2) mode='A*';
        else if(snake.length<WIDTH*HEIGHT/2) mode='Reversed';
        else mode='Hamiltonian';
    } else {
        survival=true;
        mode='Reversed';
    }

    if(mode==='A*') return aStar(head,apple,body) || {x:head.x,y:head.y};
    if(mode==='Reversed') return reversedAStar(head,apple,body) || {x:head.x,y:head.y};
    if(mode==='Hamiltonian') return hamiltonianMove(snake) || {x:head.x,y:head.y};
}

// Игровой цикл
function update(){
    const move = nextMove();
    snake.unshift({x:move.x,y:move.y});

    // Яблоко съедено
    if(move.x===apple.x && move.y===apple.y){
        placeApple();
    } else {
        snake.pop();
    }

    // Столкновение
    if(isCollision(move.x,move.y)){
        alert('Game Over!');
        snake = [{x: Math.floor(WIDTH/2), y: Math.floor(HEIGHT/2)}];
        dir={x:0,y:0};
        placeApple();
    }

    draw();
}

placeApple();
setInterval(update,100);
</script>
</body>
</html>
