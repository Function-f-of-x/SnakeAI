<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake AI</title>
<style>
  body { margin:0; background:#151515; display:flex; justify-content:center; align-items:center; height:100vh; }
  canvas { background:#151515; display:block; }
</style>
</head>
<body>
<canvas id="snakeCanvas" width="810" height="810"></canvas>
<script>
const canvas = document.getElementById("snakeCanvas");
const ctx = canvas.getContext("2d");

const GRID = 54;
const SNAKE_SIZE = 48;
const APPLE_SIZE = 51;
const ROWS = canvas.height / GRID;
const COLS = canvas.width / GRID;

let snake = [{x: Math.floor(COLS/2), y: Math.floor(ROWS/2)}];
let dir = {x:0, y:0};
let apple = spawnApple();
let survival = false;

function spawnApple() {
    let empty = [];
    for (let i=0;i<COLS;i++){
        for (let j=0;j<ROWS;j++){
            if (!snake.some(s=>s.x===i && s.y===j)) empty.push({x:i,y:j});
        }
    }
    return empty[Math.floor(Math.random()*empty.length)];
}

// ==== PATHFINDING ====
function neighbors(node){
    return [
        {x:node.x+1,y:node.y},
        {x:node.x-1,y:node.y},
        {x:node.x,y:node.y+1},
        {x:node.x,y:node.y-1}
    ].filter(n=>n.x>=0 && n.y>=0 && n.x<COLS && n.y<ROWS && !snake.some(s=>s.x===n.x && s.y===n.y));
}

function heuristic(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }

function astar(start,end){
    let open=[{node:start,g:0,h:heuristic(start,end),f:heuristic(start,end),parent:null}];
    let closed=[];
    while(open.length>0){
        open.sort((a,b)=>a.f-b.f);
        let current=open.shift();
        if(current.node.x===end.x && current.node.y===end.y){
            let path=[]; let c=current;
            while(c){ path.unshift(c.node); c=c.parent; }
            return path.slice(1); // remove head
        }
        closed.push(current.node);
        for(let n of neighbors(current.node)){
            if(closed.some(c=>c.x===n.x && c.y===n.y)) continue;
            let g=current.g+1;
            let h=heuristic(n,end);
            let f=g+h;
            let exist=open.find(o=>o.node.x===n.x && o.node.y===n.y);
            if(!exist || g<exist.g) open.push({node:n,g,h,f,parent:current});
        }
    }
    return null; // no path
}

function reversedAstar(start,end){
    let path=astar(start,end);
    if(!path) return null;
    return path.reverse();
}

// ==== SURVIVAL CHECK ====
function floodFill(x,y,visited){
    let stack=[{x,y}]; let count=0;
    while(stack.length>0){
        let n=stack.pop();
        let key=n.x+','+n.y;
        if(n.x<0||n.y<0||n.x>=COLS||n.y>=ROWS) continue;
        if(visited.has(key)) continue;
        if(snake.some(s=>s.x===n.x && s.y===n.y)) continue;
        visited.add(key); count++;
        stack.push({x:n.x+1,y:n.y});
        stack.push({x:n.x-1,y:n.y});
        stack.push({x:n.x,y:n.y+1});
        stack.push({x:n.x,y:n.y-1});
    }
    return count;
}

function safePath(path){
    let tempSnake=snake.slice();
    for(let step of path){
        tempSnake.unshift(step);
        tempSnake.pop();
    }
    let visited=new Set();
    let reachable=floodFill(tempSnake[0].x,tempSnake[0].y,visited);
    let empty=(COLS*ROWS)-tempSnake.length;
    return reachable/empty >= 0.8;
}

// ==== NEXT MOVE ====
function nextMove(){
    let path;
    // small snake -> A*, medium -> reversed
    if(snake.length<10){
        path=astar(snake[0],apple);
        if(path && !safePath(path)) path=null;
    }else{
        path=reversedAstar(snake[0],apple);
        if(path && !safePath(path)) path=null;
    }

    // Survival if no safe path
    survival=false;
    if(!path){
        survival=true;
        let moves=neighbors(snake[0]);
        let safeMoves=moves.filter(m=>{
            let tempSnake=[{x:m.x,y:m.y},...snake.slice(0,snake.length-1)];
            let visited=new Set();
            return floodFill(tempSnake[0].x,tempSnake[0].y,visited)/(COLS*ROWS-snake.length)>=0.8;
        });
        if(safeMoves.length>0){
            let chosen=safeMoves[Math.floor(Math.random()*safeMoves.length)];
            return {x:chosen.x-snake[0].x, y:chosen.y-snake[0].y};
        }else{
            return {x:0,y:0}; // stuck
        }
    }else{
        let step=path[0];
        return {x:step.x-snake[0].x, y:step.y-snake[0].y};
    }
}

// ==== GAME LOOP ====
function gameLoop(){
    let move=nextMove();
    let newHead={x:snake[0].x+move.x, y:snake[0].y+move.y};
    // collision
    if(newHead.x<0||newHead.y<0||newHead.x>=COLS||newHead.y>=ROWS || snake.some(s=>s.x===newHead.x && s.y===newHead.y)){
        alert("Game Over"); return;
    }
    snake.unshift(newHead);
    if(newHead.x===apple.x && newHead.y===apple.y){
        apple=spawnApple();
    }else{
        snake.pop();
    }
    draw();
}

function draw(){
    ctx.fillStyle="#151515";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw apple
    ctx.fillStyle="#ee0a17";
    ctx.fillRect(apple.x*GRID + (GRID-APPLE_SIZE)/2, apple.y*GRID + (GRID-APPLE_SIZE)/2, APPLE_SIZE, APPLE_SIZE);

    // draw snake
    ctx.fillStyle=survival?"#b20c18":"#3ac322";
    for(let s of snake){
        ctx.fillRect(s.x*GRID + (GRID-SNAKE_SIZE)/2, s.y*GRID + (GRID-SNAKE_SIZE)/2, SNAKE_SIZE, SNAKE_SIZE);
    }
}

setInterval(gameLoop,100); // adjust speed here
</script>
</body>
</html>
